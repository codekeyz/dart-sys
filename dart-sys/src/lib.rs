//! Opt-in style bindings to the Dart SDK
//!
//! This crate provides bindings to the Dart SDK. It is generated using
//! [bindgen](https://crates.io/crates/bindgen) and the official Dart SDK.
//!
//! Bindings are generated statically, meaning that the Dart SDK headers are
//! included in the crate and no external dependencies are required.
#![no_std]
#![allow(
	non_upper_case_globals,
	non_camel_case_types,
	non_snake_case,
	unused_variables,
	dead_code
)]
/* automatically generated by rust-bindgen 0.69.5 */

pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __darwin_intptr_t = ::core::ffi::c_long;
pub type __darwin_natural_t = ::core::ffi::c_uint;
pub type __darwin_ct_rune_t = ::core::ffi::c_int;
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::core::ffi::c_long;
pub type __darwin_size_t = ::core::ffi::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::core::ffi::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::core::ffi::c_int;
pub type __darwin_clock_t = ::core::ffi::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::core::ffi::c_long;
pub type __darwin_time_t = ::core::ffi::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::core::ffi::c_uint;
pub type __darwin_fsfilcnt_t = ::core::ffi::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::core::ffi::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::core::ffi::c_char; 37usize];
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::core::ffi::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::core::ffi::c_int;
pub type __darwin_wctrans_t = ::core::ffi::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type wchar_t = __darwin_wchar_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::core::ffi::c_long;
pub type uintmax_t = ::core::ffi::c_ulong;
#[doc = " An isolate is the unit of concurrency in Dart. Each isolate has\n its own memory and thread of control. No state is shared between\n isolates. Instead, isolates communicate by message passing.\n\n Each thread keeps track of its current isolate, which is the\n isolate which is ready to execute on the current thread. The\n current isolate may be NULL, in which case no isolate is ready to\n execute. Most of the Dart apis require there to be a current\n isolate in order to function without error. The current isolate is\n set by any call to Dart_CreateIsolateGroup or Dart_EnterIsolate."]
pub type Dart_Isolate = *mut _Dart_Isolate;
pub type Dart_IsolateGroup = *mut _Dart_IsolateGroup;
#[doc = " An object reference managed by the Dart VM garbage collector.\n\n Because the garbage collector may move objects, it is unsafe to\n refer to objects directly. Instead, we refer to objects through\n handles, which are known to the garbage collector and updated\n automatically when the object is moved. Handles should be passed\n by value (except in cases like out-parameters) and should never be\n allocated on the heap.\n\n Most functions in the Dart Embedding API return a handle. When a\n function completes normally, this will be a valid handle to an\n object in the Dart VM heap. This handle may represent the result of\n the operation or it may be a special valid handle used merely to\n indicate successful completion. Note that a valid handle may in\n some cases refer to the null object.\n\n --- Error handles ---\n\n When a function encounters a problem that prevents it from\n completing normally, it returns an error handle (See Dart_IsError).\n An error handle has an associated error message that gives more\n details about the problem (See Dart_GetError).\n\n There are four kinds of error handles that can be produced,\n depending on what goes wrong:\n\n - Api error handles are produced when an api function is misused.\n   This happens when a Dart embedding api function is called with\n   invalid arguments or in an invalid context.\n\n - Unhandled exception error handles are produced when, during the\n   execution of Dart code, an exception is thrown but not caught.\n   Prototypically this would occur during a call to Dart_Invoke, but\n   it can occur in any function which triggers the execution of Dart\n   code (for example, Dart_ToString).\n\n   An unhandled exception error provides access to an exception and\n   stacktrace via the functions Dart_ErrorGetException and\n   Dart_ErrorGetStackTrace.\n\n - Compilation error handles are produced when, during the execution\n   of Dart code, a compile-time error occurs.  As above, this can\n   occur in any function which triggers the execution of Dart code.\n\n - Fatal error handles are produced when the system wants to shut\n   down the current isolate.\n\n --- Propagating errors ---\n\n When an error handle is returned from the top level invocation of\n Dart code in a program, the embedder must handle the error as they\n see fit.  Often, the embedder will print the error message produced\n by Dart_Error and exit the program.\n\n When an error is returned while in the body of a native function,\n it can be propagated up the call stack by calling\n Dart_PropagateError, Dart_SetReturnValue, or Dart_ThrowException.\n Errors should be propagated unless there is a specific reason not\n to.  If an error is not propagated then it is ignored.  For\n example, if an unhandled exception error is ignored, that\n effectively \"catches\" the unhandled exception.  Fatal errors must\n always be propagated.\n\n When an error is propagated, any current scopes created by\n Dart_EnterScope will be exited.\n\n Using Dart_SetReturnValue to propagate an exception is somewhat\n more convenient than using Dart_PropagateError, and should be\n preferred for reasons discussed below.\n\n Dart_PropagateError and Dart_ThrowException do not return.  Instead\n they transfer control non-locally using a setjmp-like mechanism.\n This can be inconvenient if you have resources that you need to\n clean up before propagating the error.\n\n When relying on Dart_PropagateError, we often return error handles\n rather than propagating them from helper functions.  Consider the\n following contrived example:\n\n 1    Dart_Handle isLongStringHelper(Dart_Handle arg) {\n 2      intptr_t* length = 0;\n 3      result = Dart_StringLength(arg, &length);\n 4      if (Dart_IsError(result)) {\n 5        return result;\n 6      }\n 7      return Dart_NewBoolean(length > 100);\n 8    }\n 9\n 10   void NativeFunction_isLongString(Dart_NativeArguments args) {\n 11     Dart_EnterScope();\n 12     AllocateMyResource();\n 13     Dart_Handle arg = Dart_GetNativeArgument(args, 0);\n 14     Dart_Handle result = isLongStringHelper(arg);\n 15     if (Dart_IsError(result)) {\n 16       FreeMyResource();\n 17       Dart_PropagateError(result);\n 18       abort();  // will not reach here\n 19     }\n 20     Dart_SetReturnValue(result);\n 21     FreeMyResource();\n 22     Dart_ExitScope();\n 23   }\n\n In this example, we have a native function which calls a helper\n function to do its work.  On line 5, the helper function could call\n Dart_PropagateError, but that would not give the native function a\n chance to call FreeMyResource(), causing a leak.  Instead, the\n helper function returns the error handle to the caller, giving the\n caller a chance to clean up before propagating the error handle.\n\n When an error is propagated by calling Dart_SetReturnValue, the\n native function will be allowed to complete normally and then the\n exception will be propagated only once the native call\n returns. This can be convenient, as it allows the C code to clean\n up normally.\n\n The example can be written more simply using Dart_SetReturnValue to\n propagate the error.\n\n 1    Dart_Handle isLongStringHelper(Dart_Handle arg) {\n 2      intptr_t* length = 0;\n 3      result = Dart_StringLength(arg, &length);\n 4      if (Dart_IsError(result)) {\n 5        return result\n 6      }\n 7      return Dart_NewBoolean(length > 100);\n 8    }\n 9\n 10   void NativeFunction_isLongString(Dart_NativeArguments args) {\n 11     Dart_EnterScope();\n 12     AllocateMyResource();\n 13     Dart_Handle arg = Dart_GetNativeArgument(args, 0);\n 14     Dart_SetReturnValue(isLongStringHelper(arg));\n 15     FreeMyResource();\n 16     Dart_ExitScope();\n 17   }\n\n In this example, the call to Dart_SetReturnValue on line 14 will\n either return the normal return value or the error (potentially\n generated on line 3).  The call to FreeMyResource on line 15 will\n execute in either case.\n\n --- Local and persistent handles ---\n\n Local handles are allocated within the current scope (see\n Dart_EnterScope) and go away when the current scope exits. Unless\n otherwise indicated, callers should assume that all functions in\n the Dart embedding api return local handles.\n\n Persistent handles are allocated within the current isolate. They\n can be used to store objects across scopes. Persistent handles have\n the lifetime of the current isolate unless they are explicitly\n deallocated (see Dart_DeletePersistentHandle).\n The type Dart_Handle represents a handle (both local and persistent).\n The type Dart_PersistentHandle is a Dart_Handle and it is used to\n document that a persistent handle is expected as a parameter to a call\n or the return value from a call is a persistent handle.\n\n FinalizableHandles are persistent handles which are auto deleted when\n the object is garbage collected. It is never safe to use these handles\n unless you know the object is still reachable.\n\n WeakPersistentHandles are persistent handles which are automatically set\n to point Dart_Null when the object is garbage collected. They are not auto\n deleted, so it is safe to use them after the object has become unreachable."]
pub type Dart_Handle = *mut _Dart_Handle;
pub type Dart_PersistentHandle = Dart_Handle;
pub type Dart_WeakPersistentHandle = *mut _Dart_WeakPersistentHandle;
pub type Dart_FinalizableHandle = *mut _Dart_FinalizableHandle;
pub type Dart_HandleFinalizer = ::core::option::Option<
	unsafe extern "C" fn(isolate_callback_data: *mut ::core::ffi::c_void, peer: *mut ::core::ffi::c_void),
>;
#[doc = " An isolate creation and initialization callback function.\n\n This callback, provided by the embedder, is called when the VM\n needs to create an isolate. The callback should create an isolate\n by calling Dart_CreateIsolateGroup and load any scripts required for\n execution.\n\n This callback may be called on a different thread than the one\n running the parent isolate.\n\n When the function returns NULL, it is the responsibility of this\n function to ensure that Dart_ShutdownIsolate has been called if\n required (for example, if the isolate was created successfully by\n Dart_CreateIsolateGroup() but the root library fails to load\n successfully, then the function should call Dart_ShutdownIsolate\n before returning).\n\n When the function returns NULL, the function should set *error to\n a malloc-allocated buffer containing a useful error message.  The\n caller of this function (the VM) will make sure that the buffer is\n freed.\n\n \\param script_uri The uri of the main source file or snapshot to load.\n   Either the URI of the parent isolate set in Dart_CreateIsolateGroup for\n   Isolate.spawn, or the argument to Isolate.spawnUri canonicalized by the\n   library tag handler of the parent isolate.\n   The callback is responsible for loading the program by a call to\n   Dart_LoadScriptFromKernel.\n \\param main The name of the main entry point this isolate will\n   eventually run.  This is provided for advisory purposes only to\n   improve debugging messages.  The main function is not invoked by\n   this function.\n \\param package_root Ignored.\n \\param package_config Uri of the package configuration file (either in format\n   of .packages or .dart_tool/package_config.json) for this isolate\n   to resolve package imports against. If this parameter is not passed the\n   package resolution of the parent isolate should be used.\n \\param flags Default flags for this isolate being spawned. Either inherited\n   from the spawning isolate or passed as parameters when spawning the\n   isolate from Dart code.\n \\param isolate_data The isolate data which was passed to the\n   parent isolate when it was created by calling Dart_CreateIsolateGroup().\n \\param error A structure into which the embedder can place a\n   C string containing an error message in the case of failures.\n\n \\return The embedder returns NULL if the creation and\n   initialization was not successful and the isolate if successful."]
pub type Dart_IsolateGroupCreateCallback = ::core::option::Option<
	unsafe extern "C" fn(
		script_uri: *const ::core::ffi::c_char,
		main: *const ::core::ffi::c_char,
		package_root: *const ::core::ffi::c_char,
		package_config: *const ::core::ffi::c_char,
		flags: *mut Dart_IsolateFlags,
		isolate_data: *mut ::core::ffi::c_void,
		error: *mut *mut ::core::ffi::c_char,
	) -> Dart_Isolate,
>;
#[doc = " An isolate initialization callback function.\n\n This callback, provided by the embedder, is called when the VM has created an\n isolate within an existing isolate group (i.e. from the same source as an\n existing isolate).\n\n The callback should setup native resolvers and might want to set a custom\n message handler via [Dart_SetMessageNotifyCallback] and mark the isolate as\n runnable.\n\n This callback may be called on a different thread than the one\n running the parent isolate.\n\n When the function returns `false`, it is the responsibility of this\n function to ensure that `Dart_ShutdownIsolate` has been called.\n\n When the function returns `false`, the function should set *error to\n a malloc-allocated buffer containing a useful error message.  The\n caller of this function (the VM) will make sure that the buffer is\n freed.\n\n \\param child_isolate_data The callback data to associate with the new\n        child isolate.\n \\param error A structure into which the embedder can place a\n   C string containing an error message in the case the initialization fails.\n\n \\return The embedder returns true if the initialization was successful and\n         false otherwise (in which case the VM will terminate the isolate)."]
pub type Dart_InitializeIsolateCallback = ::core::option::Option<
	unsafe extern "C" fn(
		child_isolate_data: *mut *mut ::core::ffi::c_void,
		error: *mut *mut ::core::ffi::c_char,
	) -> bool,
>;
#[doc = " An isolate shutdown callback function.\n\n This callback, provided by the embedder, is called before the vm\n shuts down an isolate.  The isolate being shutdown will be the current\n isolate. It is safe to run Dart code.\n\n This function should be used to dispose of native resources that\n are allocated to an isolate in order to avoid leaks.\n\n \\param isolate_group_data The same callback data which was passed to the\n   isolate group when it was created.\n \\param isolate_data The same callback data which was passed to the isolate\n   when it was created."]
pub type Dart_IsolateShutdownCallback = ::core::option::Option<
	unsafe extern "C" fn(isolate_group_data: *mut ::core::ffi::c_void, isolate_data: *mut ::core::ffi::c_void),
>;
#[doc = " An isolate cleanup callback function.\n\n This callback, provided by the embedder, is called after the vm\n shuts down an isolate. There will be no current isolate and it is *not*\n safe to run Dart code.\n\n This function should be used to dispose of native resources that\n are allocated to an isolate in order to avoid leaks.\n\n \\param isolate_group_data The same callback data which was passed to the\n   isolate group when it was created.\n \\param isolate_data The same callback data which was passed to the isolate\n   when it was created."]
pub type Dart_IsolateCleanupCallback = ::core::option::Option<
	unsafe extern "C" fn(isolate_group_data: *mut ::core::ffi::c_void, isolate_data: *mut ::core::ffi::c_void),
>;
#[doc = " An isolate group cleanup callback function.\n\n This callback, provided by the embedder, is called after the vm\n shuts down an isolate group.\n\n This function should be used to dispose of native resources that\n are allocated to an isolate in order to avoid leaks.\n\n \\param isolate_group_data The same callback data which was passed to the\n   isolate group when it was created.\n"]
pub type Dart_IsolateGroupCleanupCallback =
	::core::option::Option<unsafe extern "C" fn(isolate_group_data: *mut ::core::ffi::c_void)>;
#[doc = " A thread start callback function.\n This callback, provided by the embedder, is called after a thread in the\n vm thread pool starts.\n This function could be used to adjust thread priority or attach native\n resources to the thread."]
pub type Dart_ThreadStartCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " A thread death callback function.\n This callback, provided by the embedder, is called before a thread in the\n vm thread pool exits.\n This function could be used to dispose of native resources that\n are associated and attached to the thread, in order to avoid leaks."]
pub type Dart_ThreadExitCallback = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Opens a file for reading or writing.\n\n Callback provided by the embedder for file operations. If the\n embedder does not allow file operations this callback can be\n NULL.\n\n \\param name The name of the file to open.\n \\param write A boolean variable which indicates if the file is to\n   opened for writing. If there is an existing file it needs to truncated."]
pub type Dart_FileOpenCallback = ::core::option::Option<
	unsafe extern "C" fn(name: *const ::core::ffi::c_char, write: bool) -> *mut ::core::ffi::c_void,
>;
#[doc = " Read contents of file.\n\n Callback provided by the embedder for file operations. If the\n embedder does not allow file operations this callback can be\n NULL.\n\n \\param data Buffer allocated in the callback into which the contents\n   of the file are read into. It is the responsibility of the caller to\n   free this buffer.\n \\param file_length A variable into which the length of the file is returned.\n   In the case of an error this value would be -1.\n \\param stream Handle to the opened file."]
pub type Dart_FileReadCallback = ::core::option::Option<
	unsafe extern "C" fn(data: *mut *mut u8, file_length: *mut isize, stream: *mut ::core::ffi::c_void),
>;
#[doc = " Write data into file.\n\n Callback provided by the embedder for file operations. If the\n embedder does not allow file operations this callback can be\n NULL.\n\n \\param data Buffer which needs to be written into the file.\n \\param length Length of the buffer.\n \\param stream Handle to the opened file."]
pub type Dart_FileWriteCallback = ::core::option::Option<
	unsafe extern "C" fn(data: *const ::core::ffi::c_void, length: isize, stream: *mut ::core::ffi::c_void),
>;
#[doc = " Closes the opened file.\n\n Callback provided by the embedder for file operations. If the\n embedder does not allow file operations this callback can be\n NULL.\n\n \\param stream Handle to the opened file."]
pub type Dart_FileCloseCallback = ::core::option::Option<unsafe extern "C" fn(stream: *mut ::core::ffi::c_void)>;
pub type Dart_EntropySource = ::core::option::Option<unsafe extern "C" fn(buffer: *mut u8, length: isize) -> bool>;
#[doc = " Callback provided by the embedder that is used by the vmservice isolate\n to request the asset archive. The asset archive must be an uncompressed tar\n archive that is stored in a Uint8List.\n\n If the embedder has no vmservice isolate assets, the callback can be NULL.\n\n \\return The embedder must return a handle to a Uint8List containing an\n   uncompressed tar archive or null."]
pub type Dart_GetVMServiceAssetsArchive = ::core::option::Option<unsafe extern "C" fn() -> Dart_Handle>;
#[doc = " Callback provided by the embedder that is used by the VM to notify on code\n object creation, *before* it is invoked the first time.\n This is useful for embedders wanting to e.g. keep track of PCs beyond\n the lifetime of the garbage collected code objects.\n Note that an address range may be used by more than one code object over the\n lifecycle of a process. Clients of this function should record timestamps for\n these compilation events and when collecting PCs to disambiguate reused\n address ranges."]
pub type Dart_OnNewCodeCallback = ::core::option::Option<
	unsafe extern "C" fn(observer: *mut Dart_CodeObserver, name: *const ::core::ffi::c_char, base: usize, size: usize),
>;
#[doc = " Optional callback provided by the embedder that is used by the VM to\n implement registration of kernel blobs for the subsequent Isolate.spawnUri\n If no callback is provided, the registration of kernel blobs will throw\n an error.\n\n \\param kernel_buffer A buffer which contains a kernel program. Callback\n                      should copy the contents of `kernel_buffer` as\n                      it may be freed immediately after registration.\n \\param kernel_buffer_size The size of `kernel_buffer`.\n\n \\return A C string representing URI which can be later used\n         to spawn a new isolate. This C String should be scope allocated\n         or owned by the embedder.\n         Returns NULL if embedder runs out of memory."]
pub type Dart_RegisterKernelBlobCallback = ::core::option::Option<
	unsafe extern "C" fn(kernel_buffer: *const u8, kernel_buffer_size: isize) -> *const ::core::ffi::c_char,
>;
#[doc = " Optional callback provided by the embedder that is used by the VM to\n unregister kernel blobs.\n If no callback is provided, the unregistration of kernel blobs will throw\n an error.\n\n \\param kernel_blob_uri URI of the kernel blob to unregister."]
pub type Dart_UnregisterKernelBlobCallback =
	::core::option::Option<unsafe extern "C" fn(kernel_blob_uri: *const ::core::ffi::c_char)>;
#[doc = " Gets an id that uniquely identifies current isolate group.\n\n It is the responsibility of the caller to free the returned ID."]
pub type Dart_IsolateGroupId = i64;
pub type Dart_HeapSamplingReportCallback =
	::core::option::Option<unsafe extern "C" fn(context: *mut ::core::ffi::c_void, data: *mut ::core::ffi::c_void)>;
pub type Dart_HeapSamplingCreateCallback = ::core::option::Option<
	unsafe extern "C" fn(
		isolate: Dart_Isolate,
		isolate_group: Dart_IsolateGroup,
		cls_name: *const ::core::ffi::c_char,
		allocation_size: isize,
	) -> *mut ::core::ffi::c_void,
>;
pub type Dart_HeapSamplingDeleteCallback = ::core::option::Option<unsafe extern "C" fn(data: *mut ::core::ffi::c_void)>;
#[doc = " A port is used to send or receive inter-isolate messages"]
pub type Dart_Port = i64;
#[doc = " A message notification callback.\n\n This callback allows the embedder to provide a custom wakeup mechanism for\n the delivery of inter-isolate messages. This function is called once per\n message on an arbitrary thread. It is the responsibility of the embedder to\n eventually call Dart_HandleMessage once per callback received with the\n destination isolate set as the current isolate to process the message."]
pub type Dart_MessageNotifyCallback = ::core::option::Option<unsafe extern "C" fn(destination_isolate: Dart_Isolate)>;
#[doc = " The arguments to a native function.\n\n This object is passed to a native function to represent its\n arguments and return value. It allows access to the arguments to a\n native function by index. It also allows the return value of a\n native function to be set."]
pub type Dart_NativeArguments = *mut _Dart_NativeArguments;
pub type Dart_NativeArgument_Descriptor = _Dart_NativeArgument_Descriptor;
pub type Dart_NativeArgument_Value = _Dart_NativeArgument_Value;
#[doc = " A native function."]
pub type Dart_NativeFunction = ::core::option::Option<unsafe extern "C" fn(arguments: Dart_NativeArguments)>;
#[doc = " Native entry resolution callback.\n\n For libraries and scripts which have native functions, the embedder\n can provide a native entry resolver. This callback is used to map a\n name/arity to a Dart_NativeFunction. If no function is found, the\n callback should return NULL.\n\n The parameters to the native resolver function are:\n \\param name a Dart string which is the name of the native function.\n \\param num_of_arguments is the number of arguments expected by the\n   native function.\n \\param auto_setup_scope is a boolean flag that can be set by the resolver\n   to indicate if this function needs a Dart API scope (see Dart_EnterScope/\n   Dart_ExitScope) to be setup automatically by the VM before calling into\n   the native function. By default most native functions would require this\n   to be true but some light weight native functions which do not call back\n   into the VM through the Dart API may not require a Dart scope to be\n   setup automatically.\n\n \\return A valid Dart_NativeFunction which resolves to a native entry point\n   for the native function.\n\n See Dart_SetNativeResolver."]
pub type Dart_NativeEntryResolver = ::core::option::Option<
	unsafe extern "C" fn(
		name: Dart_Handle,
		num_of_arguments: ::core::ffi::c_int,
		auto_setup_scope: *mut bool,
	) -> Dart_NativeFunction,
>;
#[doc = " Native entry symbol lookup callback.\n\n For libraries and scripts which have native functions, the embedder\n can provide a callback for mapping a native entry to a symbol. This callback\n maps a native function entry PC to the native function name. If no native\n entry symbol can be found, the callback should return NULL.\n\n The parameters to the native reverse resolver function are:\n \\param nf A Dart_NativeFunction.\n\n \\return A const UTF-8 string containing the symbol name or NULL.\n\n See Dart_SetNativeResolver."]
pub type Dart_NativeEntrySymbol = ::core::option::Option<unsafe extern "C" fn(nf: Dart_NativeFunction) -> *const u8>;
#[doc = " FFI Native C function pointer resolver callback.\n\n See Dart_SetFfiNativeResolver."]
pub type Dart_FfiNativeResolver = ::core::option::Option<
	unsafe extern "C" fn(name: *const ::core::ffi::c_char, args_n: usize) -> *mut ::core::ffi::c_void,
>;
#[doc = " An environment lookup callback function.\n\n \\param name The name of the value to lookup in the environment.\n\n \\return A valid handle to a string if the name exists in the\n current environment or Dart_Null() if not."]
pub type Dart_EnvironmentCallback = ::core::option::Option<unsafe extern "C" fn(name: Dart_Handle) -> Dart_Handle>;
#[doc = " Callback provided by the embedder that is used by the VM to resolve asset\n paths.\n\n The VM is responsible for looking up the asset path with the asset id in the\n kernel mapping. The embedder is responsible for providing the asset mapping\n during kernel compilation and using the asset path to return a library handle\n in this function.\n\n \\param path The string in the asset path as passed in native_assets.yaml\n             during kernel compilation.\n\n \\param error Returns NULL if successful, an error message otherwise. The\n   caller is responsible for calling free() on the error message.\n\n \\return The library handle. If |error| is not-null, the return value is\n         undefined."]
pub type Dart_NativeAssetsDlopenCallback = ::core::option::Option<
	unsafe extern "C" fn(
		path: *const ::core::ffi::c_char,
		error: *mut *mut ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_void,
>;
pub type Dart_NativeAssetsDlopenCallbackNoPath =
	::core::option::Option<unsafe extern "C" fn(error: *mut *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_void>;
#[doc = " Callback provided by the embedder that is used by the VM to resolve asset\n ids.\n\n The embedder can freely chose how to bundle asset id to asset path mappings\n and how to perform this lookup.\n\n If the embedder provides this callback, it must also provide\n `Dart_NativeAssetsAvailableAssets`.\n\n If provided, takes prescedence over `Dart_NativeAssetsDlopenCallback`.\n\n \\param path The asset id requested in the `@Native` external function.\n\n \\param error Returns NULL if successful, an error message otherwise. The\n   caller is responsible for calling free() on the error message.\n\n \\return The library handle. If |error| is not-null, the return value is\n         undefined."]
pub type Dart_NativeAssetsDlopenAssetId = ::core::option::Option<
	unsafe extern "C" fn(
		asset_id: *const ::core::ffi::c_char,
		error: *mut *mut ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_void,
>;
#[doc = " Callback provided by the embedder that is used  by the VM to request a\n description of the available assets\n\n \\return A malloced string containing all asset ids. The caller must free this\n   string."]
pub type Dart_NativeAssetsAvailableAssets = ::core::option::Option<unsafe extern "C" fn() -> *mut ::core::ffi::c_char>;
#[doc = " Callback provided by the embedder that is used by the VM to lookup symbols\n in native code assets.\n If no callback is provided, using `@Native`s with `native_asset.yaml`s will\n fail.\n\n \\param handle The library handle returned from a\n               `Dart_NativeAssetsDlopenCallback` or\n               `Dart_NativeAssetsDlopenCallbackNoPath`.\n\n \\param symbol The symbol to look up. Is a string.\n\n \\param error Returns NULL if creation is successful, an error message\n   otherwise. The caller is responsible for calling free() on the error\n   message.\n\n \\return The symbol address. If |error| is not-null, the return value is\n         undefined."]
pub type Dart_NativeAssetsDlsymCallback = ::core::option::Option<
	unsafe extern "C" fn(
		handle: *mut ::core::ffi::c_void,
		symbol: *const ::core::ffi::c_char,
		error: *mut *mut ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_void,
>;
#[doc = " The library tag handler is a multi-purpose callback provided by the\n embedder to the Dart VM. The embedder implements the tag handler to\n provide the ability to load Dart scripts and imports.\n\n -- TAGS --\n\n Dart_kCanonicalizeUrl\n\n This tag indicates that the embedder should canonicalize 'url' with\n respect to 'library'.  For most embedders, this is resolving the `url`\n relative to the `library`s url (see `Dart_LibraryUrl`).\n\n Dart_kImportTag\n\n This tag is used to load a library from IsolateMirror.loadUri. The embedder\n should call Dart_LoadLibraryFromKernel to provide the library to the VM. The\n return value should be an error or library (the result from\n Dart_LoadLibraryFromKernel).\n\n Dart_kKernelTag\n\n This tag is used to load the intermediate file (kernel) generated by\n the Dart front end. This tag is typically used when a 'hot-reload'\n of an application is needed and the VM is 'use dart front end' mode.\n The dart front end typically compiles all the scripts, imports and part\n files into one intermediate file hence we don't use the source/import or\n script tags. The return value should be an error or a TypedData containing\n the kernel bytes.\n"]
pub type Dart_LibraryTagHandler = ::core::option::Option<
	unsafe extern "C" fn(
		tag: Dart_LibraryTag,
		library_or_package_map_url: Dart_Handle,
		url: Dart_Handle,
	) -> Dart_Handle,
>;
#[doc = " Handles deferred loading requests. When this handler is invoked, it should\n eventually load the deferred loading unit with the given id and call\n Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError. It is\n recommended that the loading occur asynchronously, but it is permitted to\n call Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError before the\n handler returns.\n\n If an error is returned, it will be propagated through\n `prefix.loadLibrary()`. This is useful for synchronous\n implementations, which must propagate any unwind errors from\n Dart_DeferredLoadComplete or Dart_DeferredLoadComplete. Otherwise the handler\n should return a non-error such as `Dart_Null()`."]
pub type Dart_DeferredLoadHandler = ::core::option::Option<unsafe extern "C" fn(loading_unit_id: isize) -> Dart_Handle>;
pub type Dart_CreateLoadingUnitCallback = ::core::option::Option<
	unsafe extern "C" fn(
		callback_data: *mut ::core::ffi::c_void,
		loading_unit_id: isize,
		write_callback_data: *mut *mut ::core::ffi::c_void,
		write_debug_callback_data: *mut *mut ::core::ffi::c_void,
	),
>;
pub type Dart_StreamingWriteCallback = ::core::option::Option<
	unsafe extern "C" fn(callback_data: *mut ::core::ffi::c_void, buffer: *const u8, size: isize),
>;
pub type Dart_StreamingCloseCallback =
	::core::option::Option<unsafe extern "C" fn(callback_data: *mut ::core::ffi::c_void)>;
#[doc = " Callback provided by the embedder that is used by the VM to\n produce footnotes appended to DWARF stack traces.\n\n Whenever VM formats a stack trace as a string it would call this callback\n passing raw program counters for each frame in the stack trace.\n\n Embedder can then return a string which if not-null will be appended to the\n formatted stack trace.\n\n Returned string is expected to be `malloc()` allocated. VM takes ownership\n of the returned string and will `free()` it.\n\n \\param addresses raw program counter addresses for each frame\n \\param count number of elements in the addresses array"]
pub type Dart_DwarfStackTraceFootnoteCallback = ::core::option::Option<
	unsafe extern "C" fn(addresses: *mut *mut ::core::ffi::c_void, count: isize) -> *mut ::core::ffi::c_char,
>;
pub type Dart_CObject = _Dart_CObject;
#[doc = " A native message handler.\n\n This handler is associated with a native port by calling\n Dart_NewNativePort.\n\n The message received is decoded into the message structure. The\n lifetime of the message data is controlled by the caller. All the\n data references from the message are allocated by the caller and\n will be reclaimed when returning to it."]
pub type Dart_NativeMessageHandler =
	::core::option::Option<unsafe extern "C" fn(dest_port_id: Dart_Port, message: *mut Dart_CObject)>;
pub type Dart_Port_DL = i64;
pub type Dart_NativeMessageHandler_DL =
	::core::option::Option<unsafe extern "C" fn(dest_port_id: Dart_Port_DL, message: *mut Dart_CObject)>;
pub type Dart_PostCObject_Type =
	::core::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL, message: *mut Dart_CObject) -> bool>;
pub type Dart_PostInteger_Type =
	::core::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL, message: i64) -> bool>;
pub type Dart_NewNativePort_Type = ::core::option::Option<
	unsafe extern "C" fn(
		name: *const ::core::ffi::c_char,
		handler: Dart_NativeMessageHandler_DL,
		handle_concurrently: bool,
	) -> Dart_Port_DL,
>;
pub type Dart_CloseNativePort_Type = ::core::option::Option<unsafe extern "C" fn(native_port_id: Dart_Port_DL) -> bool>;
pub type Dart_IsError_Type = ::core::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
pub type Dart_IsApiError_Type = ::core::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
pub type Dart_IsUnhandledExceptionError_Type =
	::core::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
pub type Dart_IsCompilationError_Type = ::core::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
pub type Dart_IsFatalError_Type = ::core::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
pub type Dart_GetError_Type =
	::core::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> *const ::core::ffi::c_char>;
pub type Dart_ErrorHasException_Type = ::core::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
pub type Dart_ErrorGetException_Type = ::core::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> Dart_Handle>;
pub type Dart_ErrorGetStackTrace_Type =
	::core::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> Dart_Handle>;
pub type Dart_NewApiError_Type =
	::core::option::Option<unsafe extern "C" fn(error: *const ::core::ffi::c_char) -> Dart_Handle>;
pub type Dart_NewCompilationError_Type =
	::core::option::Option<unsafe extern "C" fn(error: *const ::core::ffi::c_char) -> Dart_Handle>;
pub type Dart_NewUnhandledExceptionError_Type =
	::core::option::Option<unsafe extern "C" fn(exception: Dart_Handle) -> Dart_Handle>;
pub type Dart_PropagateError_Type = ::core::option::Option<unsafe extern "C" fn(handle: Dart_Handle)>;
pub type Dart_HandleFromPersistent_Type =
	::core::option::Option<unsafe extern "C" fn(object: Dart_PersistentHandle) -> Dart_Handle>;
pub type Dart_HandleFromWeakPersistent_Type =
	::core::option::Option<unsafe extern "C" fn(object: Dart_WeakPersistentHandle) -> Dart_Handle>;
pub type Dart_NewPersistentHandle_Type =
	::core::option::Option<unsafe extern "C" fn(object: Dart_Handle) -> Dart_PersistentHandle>;
pub type Dart_SetPersistentHandle_Type =
	::core::option::Option<unsafe extern "C" fn(obj1: Dart_PersistentHandle, obj2: Dart_Handle)>;
pub type Dart_DeletePersistentHandle_Type = ::core::option::Option<unsafe extern "C" fn(object: Dart_PersistentHandle)>;
pub type Dart_NewWeakPersistentHandle_Type = ::core::option::Option<
	unsafe extern "C" fn(
		object: Dart_Handle,
		peer: *mut ::core::ffi::c_void,
		external_allocation_size: isize,
		callback: Dart_HandleFinalizer,
	) -> Dart_WeakPersistentHandle,
>;
pub type Dart_DeleteWeakPersistentHandle_Type =
	::core::option::Option<unsafe extern "C" fn(object: Dart_WeakPersistentHandle)>;
pub type Dart_NewFinalizableHandle_Type = ::core::option::Option<
	unsafe extern "C" fn(
		object: Dart_Handle,
		peer: *mut ::core::ffi::c_void,
		external_allocation_size: isize,
		callback: Dart_HandleFinalizer,
	) -> Dart_FinalizableHandle,
>;
pub type Dart_DeleteFinalizableHandle_Type =
	::core::option::Option<unsafe extern "C" fn(object: Dart_FinalizableHandle, strong_ref_to_object: Dart_Handle)>;
pub type Dart_CurrentIsolate_Type = ::core::option::Option<unsafe extern "C" fn() -> Dart_Isolate>;
pub type Dart_ExitIsolate_Type = ::core::option::Option<unsafe extern "C" fn()>;
pub type Dart_EnterIsolate_Type = ::core::option::Option<unsafe extern "C" fn(arg1: Dart_Isolate)>;
pub type Dart_Post_Type =
	::core::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL, object: Dart_Handle) -> bool>;
pub type Dart_NewSendPort_Type = ::core::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL) -> Dart_Handle>;
pub type Dart_NewSendPortEx_Type =
	::core::option::Option<unsafe extern "C" fn(portex_id: Dart_PortEx_DL) -> Dart_Handle>;
pub type Dart_SendPortGetId_Type =
	::core::option::Option<unsafe extern "C" fn(port: Dart_Handle, port_id: *mut Dart_Port_DL) -> Dart_Handle>;
pub type Dart_SendPortGetIdEx_Type =
	::core::option::Option<unsafe extern "C" fn(port: Dart_Handle, portex_id: *mut Dart_PortEx_DL) -> Dart_Handle>;
pub type Dart_EnterScope_Type = ::core::option::Option<unsafe extern "C" fn()>;
pub type Dart_ExitScope_Type = ::core::option::Option<unsafe extern "C" fn()>;
pub type Dart_IsNull_Type = ::core::option::Option<unsafe extern "C" fn(arg1: Dart_Handle) -> bool>;
pub type Dart_Null_Type = ::core::option::Option<unsafe extern "C" fn() -> Dart_Handle>;
pub type Dart_UpdateExternalSize_Type =
	::core::option::Option<unsafe extern "C" fn(object: Dart_WeakPersistentHandle, external_allocation_size: isize)>;
pub type Dart_UpdateFinalizableExternalSize_Type = ::core::option::Option<
	unsafe extern "C" fn(
		object: Dart_FinalizableHandle,
		strong_ref_to_object: Dart_Handle,
		external_allocation_size: isize,
	),
>;
#[doc = " A service request callback function.\n\n These callbacks, registered by the embedder, are called when the VM receives\n a service request it can't handle and the service request command name\n matches one of the embedder registered handlers.\n\n The return value of the callback indicates whether the response\n should be used as a regular result or an error result.\n Specifically, if the callback returns true, a regular JSON-RPC\n response is built in the following way:\n\n {\n   \"jsonrpc\": \"2.0\",\n   \"result\": <json_object>,\n   \"id\": <some sequence id>,\n }\n\n If the callback returns false, a JSON-RPC error is built like this:\n\n {\n   \"jsonrpc\": \"2.0\",\n   \"error\": <json_object>,\n   \"id\": <some sequence id>,\n }\n\n \\param method The rpc method name.\n \\param param_keys Service requests can have key-value pair parameters. The\n   keys and values are flattened and stored in arrays.\n \\param param_values The values associated with the keys.\n \\param num_params The length of the param_keys and param_values arrays.\n \\param user_data The user_data pointer registered with this handler.\n \\param result A C string containing a valid JSON object. The returned\n   pointer will be freed by the VM by calling free.\n\n \\return True if the result is a regular JSON-RPC response, false if the\n   result is a JSON-RPC error."]
pub type Dart_ServiceRequestCallback = ::core::option::Option<
	unsafe extern "C" fn(
		method: *const ::core::ffi::c_char,
		param_keys: *mut *const ::core::ffi::c_char,
		param_values: *mut *const ::core::ffi::c_char,
		num_params: isize,
		user_data: *mut ::core::ffi::c_void,
		json_object: *mut *const ::core::ffi::c_char,
	) -> bool,
>;
#[doc = " Callback provided by the embedder that is used by the VM to request\n information.\n\n \\return Returns a pointer to a Dart_EmbedderInformation structure.\n The embedder keeps the ownership of the structure and any field in it.\n The embedder must ensure that the structure will remain valid until the\n next invocation of the callback."]
pub type Dart_EmbedderInformationCallback =
	::core::option::Option<unsafe extern "C" fn(info: *mut Dart_EmbedderInformation)>;
#[doc = " A callback invoked when the VM service gets a request to listen to\n some stream.\n\n \\return Returns true iff the embedder supports the named stream id."]
pub type Dart_ServiceStreamListenCallback =
	::core::option::Option<unsafe extern "C" fn(stream_id: *const ::core::ffi::c_char) -> bool>;
#[doc = " A callback invoked when the VM service gets a request to cancel\n some stream."]
pub type Dart_ServiceStreamCancelCallback =
	::core::option::Option<unsafe extern "C" fn(stream_id: *const ::core::ffi::c_char)>;
#[doc = " A callback which determines whether the file at some url has been\n modified since some time.  If the file cannot be found, true should\n be returned."]
pub type Dart_FileModifiedCallback =
	::core::option::Option<unsafe extern "C" fn(url: *const ::core::ffi::c_char, since: i64) -> bool>;
#[doc = " Callback provided by the embedder to handle the completion of timeline\n events.\n\n \\param event A timeline event that has just been completed. The VM keeps\n ownership of the event and any field in it (i.e., the embedder should copy\n any values it needs after the callback returns)."]
pub type Dart_TimelineRecorderCallback =
	::core::option::Option<unsafe extern "C" fn(event: *mut Dart_TimelineRecorderEvent)>;
#[doc = " Callback provided by the caller of `Dart_WriteHeapSnapshot` which is\n used to write out chunks of the requested heap snapshot.\n\n \\param context An opaque context which was passed to `Dart_WriteHeapSnapshot`\n   together with this callback.\n\n \\param buffer Pointer to the buffer containing a chunk of the snapshot.\n   The callback owns the buffer and needs to `free` it.\n\n \\param size Number of bytes in the `buffer` to be written.\n\n \\param is_last Set to `true` for the last chunk. The callback will not\n   be invoked again after it was invoked once with `is_last` set to `true`."]
pub type Dart_HeapSnapshotWriteChunkCallback = ::core::option::Option<
	unsafe extern "C" fn(context: *mut ::core::ffi::c_void, buffer: *mut u8, size: isize, is_last: bool),
>;
pub type __builtin_va_list = *mut ::core::ffi::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
	pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
	pub __arg: *mut ::core::ffi::c_void,
	pub __next: *mut __darwin_pthread_handler_rec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
	pub __sig: ::core::ffi::c_long,
	pub __opaque: [::core::ffi::c_char; 56usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
	pub __sig: ::core::ffi::c_long,
	pub __opaque: [::core::ffi::c_char; 40usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
	pub __sig: ::core::ffi::c_long,
	pub __opaque: [::core::ffi::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
	pub __sig: ::core::ffi::c_long,
	pub __opaque: [::core::ffi::c_char; 56usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
	pub __sig: ::core::ffi::c_long,
	pub __opaque: [::core::ffi::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
	pub __sig: ::core::ffi::c_long,
	pub __opaque: [::core::ffi::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
	pub __sig: ::core::ffi::c_long,
	pub __opaque: [::core::ffi::c_char; 192usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
	pub __sig: ::core::ffi::c_long,
	pub __opaque: [::core::ffi::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
	pub __sig: ::core::ffi::c_long,
	pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
	pub __opaque: [::core::ffi::c_char; 8176usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
	pub quot: intmax_t,
	pub rem: intmax_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_Isolate {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_IsolateGroup {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_Handle {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_WeakPersistentHandle {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_FinalizableHandle {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_IsolateFlags {
	pub version: i32,
	pub enable_asserts: bool,
	pub use_field_guards: bool,
	pub use_osr: bool,
	pub obfuscate: bool,
	pub load_vmservice_library: bool,
	pub null_safety: bool,
	pub is_system_isolate: bool,
	pub is_service_isolate: bool,
	pub is_kernel_isolate: bool,
	pub snapshot_is_dontneed_safe: bool,
	pub branch_coverage: bool,
	pub coverage: bool,
}
#[doc = " Forward declaration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_CodeObserver {
	pub data: *mut ::core::ffi::c_void,
	pub on_new_code: Dart_OnNewCodeCallback,
}
#[doc = " Describes how to initialize the VM. Used with Dart_Initialize."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_InitializeParams {
	#[doc = " Identifies the version of the struct used by the client.\n should be initialized to DART_INITIALIZE_PARAMS_CURRENT_VERSION."]
	pub version: i32,
	#[doc = " A buffer containing snapshot data, or NULL if no snapshot is provided.\n\n If provided, the buffer must remain valid until Dart_Cleanup returns."]
	pub vm_snapshot_data: *const u8,
	#[doc = " A buffer containing a snapshot of precompiled instructions, or NULL if\n no snapshot is provided.\n\n If provided, the buffer must remain valid until Dart_Cleanup returns."]
	pub vm_snapshot_instructions: *const u8,
	#[doc = " A function to be called during isolate group creation.\n See Dart_IsolateGroupCreateCallback."]
	pub create_group: Dart_IsolateGroupCreateCallback,
	#[doc = " A function to be called during isolate\n initialization inside an existing isolate group.\n See Dart_InitializeIsolateCallback."]
	pub initialize_isolate: Dart_InitializeIsolateCallback,
	#[doc = " A function to be called right before an isolate is shutdown.\n See Dart_IsolateShutdownCallback."]
	pub shutdown_isolate: Dart_IsolateShutdownCallback,
	#[doc = " A function to be called after an isolate was shutdown.\n See Dart_IsolateCleanupCallback."]
	pub cleanup_isolate: Dart_IsolateCleanupCallback,
	#[doc = " A function to be called after an isolate group is\n shutdown. See Dart_IsolateGroupCleanupCallback."]
	pub cleanup_group: Dart_IsolateGroupCleanupCallback,
	pub thread_start: Dart_ThreadStartCallback,
	pub thread_exit: Dart_ThreadExitCallback,
	pub file_open: Dart_FileOpenCallback,
	pub file_read: Dart_FileReadCallback,
	pub file_write: Dart_FileWriteCallback,
	pub file_close: Dart_FileCloseCallback,
	pub entropy_source: Dart_EntropySource,
	#[doc = " A function to be called by the service isolate when it requires the\n vmservice assets archive. See Dart_GetVMServiceAssetsArchive."]
	pub get_service_assets: Dart_GetVMServiceAssetsArchive,
	pub start_kernel_isolate: bool,
	#[doc = " An external code observer callback function. The observer can be invoked\n as early as during the Dart_Initialize() call."]
	pub code_observer: *mut Dart_CodeObserver,
	#[doc = " Kernel blob registration callback function. See Dart_RegisterKernelBlobCallback."]
	pub register_kernel_blob: Dart_RegisterKernelBlobCallback,
	#[doc = " Kernel blob unregistration callback function. See Dart_UnregisterKernelBlobCallback."]
	pub unregister_kernel_blob: Dart_UnregisterKernelBlobCallback,
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Dart_PerformanceMode(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_PortEx {
	pub port_id: i64,
	pub origin_id: i64,
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Dart_TypedData_Type(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArguments {
	_unused: [u8; 0],
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Dart_NativeArgument_Type(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArgument_Descriptor {
	pub type_: u8,
	pub index: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArgument_Value__bindgen_ty_1 {
	pub dart_str: Dart_Handle,
	pub peer: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArgument_Value__bindgen_ty_2 {
	pub num_fields: isize,
	pub values: *mut isize,
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _bindgen_ty_1(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NativeAssetsApi {
	pub dlopen_absolute: Dart_NativeAssetsDlopenCallback,
	pub dlopen_relative: Dart_NativeAssetsDlopenCallback,
	pub dlopen_system: Dart_NativeAssetsDlopenCallback,
	pub dlopen_process: Dart_NativeAssetsDlopenCallbackNoPath,
	pub dlopen_executable: Dart_NativeAssetsDlopenCallbackNoPath,
	pub dlsym: Dart_NativeAssetsDlsymCallback,
	pub dlopen: Dart_NativeAssetsDlopenAssetId,
	pub available_assets: Dart_NativeAssetsAvailableAssets,
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Dart_LibraryTag(pub ::core::ffi::c_uint);
#[repr(transparent)]
#[doc = " Experimental support for Dart to Kernel parser isolate.\n\n TODO(hausner): Document finalized interface.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Dart_KernelCompilationStatus(pub ::core::ffi::c_int);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_KernelCompilationResult {
	pub status: Dart_KernelCompilationStatus,
	pub error: *mut ::core::ffi::c_char,
	pub kernel: *mut u8,
	pub kernel_size: isize,
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Dart_KernelCompilationVerbosityLevel(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_SourceFile {
	pub uri: *const ::core::ffi::c_char,
	pub source: *const ::core::ffi::c_char,
}
#[repr(transparent)]
#[doc = " A Dart_CObject is used for representing Dart objects as native C\n data outside the Dart heap. These objects are totally detached from\n the Dart heap. Only a subset of the Dart objects have a\n representation as a Dart_CObject.\n\n The string encoding in the 'value.as_string' is UTF-8.\n\n All the different types from dart:typed_data are exposed as type\n kTypedData. The specific type from dart:typed_data is in the type\n field of the as_typed_data structure. The length in the\n as_typed_data structure is always in bytes.\n\n The data for kTypedData is copied on message send and ownership remains with\n the caller. The ownership of data for kExternalTyped is passed to the VM on\n message send and returned when the VM invokes the\n Dart_HandleFinalizer callback; a non-NULL callback must be provided.\n\n Note that Dart_CObject_kNativePointer is intended for internal use by\n dart:io implementation and has no connection to dart:ffi Pointer class.\n It represents a pointer to a native resource of a known type.\n The receiving side will only see this pointer as an integer and will not\n see the specified finalizer.\n The specified finalizer will only be invoked if the message is not delivered."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Dart_CObject_Type(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Dart_CObject {
	pub type_: Dart_CObject_Type,
	pub value: _Dart_CObject__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_1 {
	pub id: Dart_Port,
	pub origin_id: Dart_Port,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_2 {
	pub id: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_3 {
	pub length: isize,
	pub values: *mut *mut _Dart_CObject,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_4 {
	pub type_: Dart_TypedData_Type,
	pub length: isize,
	pub values: *const u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_5 {
	pub type_: Dart_TypedData_Type,
	pub length: isize,
	pub data: *mut u8,
	pub peer: *mut ::core::ffi::c_void,
	pub callback: Dart_HandleFinalizer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_6 {
	pub ptr: isize,
	pub size: isize,
	pub callback: Dart_HandleFinalizer,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_PortEx_DL {
	pub port_id: i64,
	pub origin_id: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_EmbedderInformation {
	pub version: i32,
	pub name: *const ::core::ffi::c_char,
	pub current_rss: i64,
	pub max_rss: i64,
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Dart_Timeline_Event_Type(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_TimelineRecorderEvent_Argument {
	pub name: *const ::core::ffi::c_char,
	pub value: *const ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_TimelineRecorderEvent {
	pub version: i32,
	pub type_: Dart_Timeline_Event_Type,
	pub timestamp0: i64,
	#[doc = " For a duration event, this is the end time. For an async event, this is the\n async ID. For a flow event, this is the flow ID. For a begin or end event,\n this is the event ID (which is only referenced by the MacOS recorder)."]
	pub timestamp1_or_id: i64,
	pub isolate: Dart_Port,
	pub isolate_group: Dart_IsolateGroupId,
	pub isolate_data: *mut ::core::ffi::c_void,
	pub isolate_group_data: *mut ::core::ffi::c_void,
	pub label: *const ::core::ffi::c_char,
	pub stream: *const ::core::ffi::c_char,
	pub argument_count: isize,
	pub arguments: *mut Dart_TimelineRecorderEvent_Argument,
}
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_15_0: u32 = 150000;
pub const __MAC_15_1: u32 = 150100;
pub const __MAC_15_2: u32 = 150200;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_18_0: u32 = 180000;
pub const __IPHONE_18_1: u32 = 180100;
pub const __IPHONE_18_2: u32 = 180200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __WATCHOS_11_1: u32 = 110100;
pub const __WATCHOS_11_2: u32 = 110200;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_18_0: u32 = 180000;
pub const __TVOS_18_1: u32 = 180100;
pub const __TVOS_18_2: u32 = 180200;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __BRIDGEOS_9_1: u32 = 90100;
pub const __BRIDGEOS_9_2: u32 = 90200;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __DRIVERKIT_24_1: u32 = 240100;
pub const __DRIVERKIT_24_2: u32 = 240200;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_2_0: u32 = 20000;
pub const __VISIONOS_2_1: u32 = 20100;
pub const __VISIONOS_2_2: u32 = 20200;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const MAC_OS_VERSION_15_1: u32 = 150100;
pub const MAC_OS_VERSION_15_2: u32 = 150200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 150200;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const DART_FLAGS_CURRENT_VERSION: u32 = 13;
pub const DART_INITIALIZE_PARAMS_CURRENT_VERSION: u32 = 8;
pub const DART_KERNEL_ISOLATE_NAME: &[u8; 15] = b"kernel-service\0";
pub const DART_VM_SERVICE_ISOLATE_NAME: &[u8; 11] = b"vm-service\0";
pub const kSnapshotBuildIdCSymbol: &[u8; 21] = b"kDartSnapshotBuildId\0";
pub const kVmSnapshotDataCSymbol: &[u8; 20] = b"kDartVmSnapshotData\0";
pub const kVmSnapshotInstructionsCSymbol: &[u8; 28] = b"kDartVmSnapshotInstructions\0";
pub const kVmSnapshotBssCSymbol: &[u8; 19] = b"kDartVmSnapshotBss\0";
pub const kIsolateSnapshotDataCSymbol: &[u8; 25] = b"kDartIsolateSnapshotData\0";
pub const kIsolateSnapshotInstructionsCSymbol: &[u8; 33] = b"kDartIsolateSnapshotInstructions\0";
pub const kIsolateSnapshotBssCSymbol: &[u8; 24] = b"kDartIsolateSnapshotBss\0";
pub const kSnapshotBuildIdAsmSymbol: &[u8; 22] = b"_kDartSnapshotBuildId\0";
pub const kVmSnapshotDataAsmSymbol: &[u8; 21] = b"_kDartVmSnapshotData\0";
pub const kVmSnapshotInstructionsAsmSymbol: &[u8; 29] = b"_kDartVmSnapshotInstructions\0";
pub const kVmSnapshotBssAsmSymbol: &[u8; 20] = b"_kDartVmSnapshotBss\0";
pub const kIsolateSnapshotDataAsmSymbol: &[u8; 26] = b"_kDartIsolateSnapshotData\0";
pub const kIsolateSnapshotInstructionsAsmSymbol: &[u8; 34] = b"_kDartIsolateSnapshotInstructions\0";
pub const kIsolateSnapshotBssAsmSymbol: &[u8; 25] = b"_kDartIsolateSnapshotBss\0";
pub const DART_API_DL_MAJOR_VERSION: u32 = 2;
pub const DART_API_DL_MINOR_VERSION: u32 = 5;
pub const ILLEGAL_ISOLATE_GROUP_ID: u32 = 0;
pub const DART_EMBEDDER_INFORMATION_CURRENT_VERSION: u32 = 1;
pub const DART_TIMELINE_RECORDER_CURRENT_VERSION: u32 = 2;
#[doc = " Balanced"]
pub const Dart_PerformanceMode_Dart_PerformanceMode_Default: Dart_PerformanceMode = Dart_PerformanceMode(0);
#[doc = " Optimize for low latency, at the expense of throughput and memory overhead\n by performing work in smaller batches (requiring more overhead) or by\n delaying work (requiring more memory). An embedder should not remain in\n this mode indefinitely."]
pub const Dart_PerformanceMode_Dart_PerformanceMode_Latency: Dart_PerformanceMode = Dart_PerformanceMode(1);
#[doc = " Optimize for high throughput, at the expense of latency and memory overhead\n by performing work in larger batches with more intervening growth."]
pub const Dart_PerformanceMode_Dart_PerformanceMode_Throughput: Dart_PerformanceMode = Dart_PerformanceMode(2);
#[doc = " Optimize for low memory, at the expensive of throughput and latency by more\n frequently performing work."]
pub const Dart_PerformanceMode_Dart_PerformanceMode_Memory: Dart_PerformanceMode = Dart_PerformanceMode(3);
pub const Dart_TypedData_Type_Dart_TypedData_kByteData: Dart_TypedData_Type = Dart_TypedData_Type(0);
pub const Dart_TypedData_Type_Dart_TypedData_kInt8: Dart_TypedData_Type = Dart_TypedData_Type(1);
pub const Dart_TypedData_Type_Dart_TypedData_kUint8: Dart_TypedData_Type = Dart_TypedData_Type(2);
pub const Dart_TypedData_Type_Dart_TypedData_kUint8Clamped: Dart_TypedData_Type = Dart_TypedData_Type(3);
pub const Dart_TypedData_Type_Dart_TypedData_kInt16: Dart_TypedData_Type = Dart_TypedData_Type(4);
pub const Dart_TypedData_Type_Dart_TypedData_kUint16: Dart_TypedData_Type = Dart_TypedData_Type(5);
pub const Dart_TypedData_Type_Dart_TypedData_kInt32: Dart_TypedData_Type = Dart_TypedData_Type(6);
pub const Dart_TypedData_Type_Dart_TypedData_kUint32: Dart_TypedData_Type = Dart_TypedData_Type(7);
pub const Dart_TypedData_Type_Dart_TypedData_kInt64: Dart_TypedData_Type = Dart_TypedData_Type(8);
pub const Dart_TypedData_Type_Dart_TypedData_kUint64: Dart_TypedData_Type = Dart_TypedData_Type(9);
pub const Dart_TypedData_Type_Dart_TypedData_kFloat32: Dart_TypedData_Type = Dart_TypedData_Type(10);
pub const Dart_TypedData_Type_Dart_TypedData_kFloat64: Dart_TypedData_Type = Dart_TypedData_Type(11);
pub const Dart_TypedData_Type_Dart_TypedData_kInt32x4: Dart_TypedData_Type = Dart_TypedData_Type(12);
pub const Dart_TypedData_Type_Dart_TypedData_kFloat32x4: Dart_TypedData_Type = Dart_TypedData_Type(13);
pub const Dart_TypedData_Type_Dart_TypedData_kFloat64x2: Dart_TypedData_Type = Dart_TypedData_Type(14);
pub const Dart_TypedData_Type_Dart_TypedData_kInvalid: Dart_TypedData_Type = Dart_TypedData_Type(15);
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kBool: Dart_NativeArgument_Type = Dart_NativeArgument_Type(0);
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kInt32: Dart_NativeArgument_Type = Dart_NativeArgument_Type(1);
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kUint32: Dart_NativeArgument_Type = Dart_NativeArgument_Type(2);
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kInt64: Dart_NativeArgument_Type = Dart_NativeArgument_Type(3);
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kUint64: Dart_NativeArgument_Type = Dart_NativeArgument_Type(4);
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kDouble: Dart_NativeArgument_Type = Dart_NativeArgument_Type(5);
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kString: Dart_NativeArgument_Type = Dart_NativeArgument_Type(6);
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kInstance: Dart_NativeArgument_Type =
	Dart_NativeArgument_Type(7);
pub const Dart_NativeArgument_Type_Dart_NativeArgument_kNativeFields: Dart_NativeArgument_Type =
	Dart_NativeArgument_Type(8);
pub const kNativeArgNumberPos: _bindgen_ty_1 = _bindgen_ty_1(0);
pub const kNativeArgNumberSize: _bindgen_ty_1 = _bindgen_ty_1(8);
pub const kNativeArgTypePos: _bindgen_ty_1 = _bindgen_ty_1(8);
pub const kNativeArgTypeSize: _bindgen_ty_1 = _bindgen_ty_1(8);
pub const Dart_LibraryTag_Dart_kCanonicalizeUrl: Dart_LibraryTag = Dart_LibraryTag(0);
pub const Dart_LibraryTag_Dart_kImportTag: Dart_LibraryTag = Dart_LibraryTag(1);
pub const Dart_LibraryTag_Dart_kKernelTag: Dart_LibraryTag = Dart_LibraryTag(2);
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Unknown: Dart_KernelCompilationStatus =
	Dart_KernelCompilationStatus(-1);
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Ok: Dart_KernelCompilationStatus =
	Dart_KernelCompilationStatus(0);
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Error: Dart_KernelCompilationStatus =
	Dart_KernelCompilationStatus(1);
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Crash: Dart_KernelCompilationStatus =
	Dart_KernelCompilationStatus(2);
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_MsgFailed: Dart_KernelCompilationStatus =
	Dart_KernelCompilationStatus(3);
pub const Dart_KernelCompilationVerbosityLevel_Dart_KernelCompilationVerbosityLevel_Error:
	Dart_KernelCompilationVerbosityLevel = Dart_KernelCompilationVerbosityLevel(0);
pub const Dart_KernelCompilationVerbosityLevel_Dart_KernelCompilationVerbosityLevel_Warning:
	Dart_KernelCompilationVerbosityLevel = Dart_KernelCompilationVerbosityLevel(1);
pub const Dart_KernelCompilationVerbosityLevel_Dart_KernelCompilationVerbosityLevel_Info:
	Dart_KernelCompilationVerbosityLevel = Dart_KernelCompilationVerbosityLevel(2);
pub const Dart_KernelCompilationVerbosityLevel_Dart_KernelCompilationVerbosityLevel_All:
	Dart_KernelCompilationVerbosityLevel = Dart_KernelCompilationVerbosityLevel(3);
pub const Dart_CObject_Type_Dart_CObject_kNull: Dart_CObject_Type = Dart_CObject_Type(0);
pub const Dart_CObject_Type_Dart_CObject_kBool: Dart_CObject_Type = Dart_CObject_Type(1);
pub const Dart_CObject_Type_Dart_CObject_kInt32: Dart_CObject_Type = Dart_CObject_Type(2);
pub const Dart_CObject_Type_Dart_CObject_kInt64: Dart_CObject_Type = Dart_CObject_Type(3);
pub const Dart_CObject_Type_Dart_CObject_kDouble: Dart_CObject_Type = Dart_CObject_Type(4);
pub const Dart_CObject_Type_Dart_CObject_kString: Dart_CObject_Type = Dart_CObject_Type(5);
pub const Dart_CObject_Type_Dart_CObject_kArray: Dart_CObject_Type = Dart_CObject_Type(6);
pub const Dart_CObject_Type_Dart_CObject_kTypedData: Dart_CObject_Type = Dart_CObject_Type(7);
pub const Dart_CObject_Type_Dart_CObject_kExternalTypedData: Dart_CObject_Type = Dart_CObject_Type(8);
pub const Dart_CObject_Type_Dart_CObject_kSendPort: Dart_CObject_Type = Dart_CObject_Type(9);
pub const Dart_CObject_Type_Dart_CObject_kCapability: Dart_CObject_Type = Dart_CObject_Type(10);
pub const Dart_CObject_Type_Dart_CObject_kNativePointer: Dart_CObject_Type = Dart_CObject_Type(11);
pub const Dart_CObject_Type_Dart_CObject_kUnsupported: Dart_CObject_Type = Dart_CObject_Type(12);
pub const Dart_CObject_Type_Dart_CObject_kUnmodifiableExternalTypedData: Dart_CObject_Type = Dart_CObject_Type(13);
pub const Dart_CObject_Type_Dart_CObject_kNumberOfTypes: Dart_CObject_Type = Dart_CObject_Type(14);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_Begin: Dart_Timeline_Event_Type = Dart_Timeline_Event_Type(0);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_End: Dart_Timeline_Event_Type = Dart_Timeline_Event_Type(1);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_Instant: Dart_Timeline_Event_Type = Dart_Timeline_Event_Type(2);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_Duration: Dart_Timeline_Event_Type = Dart_Timeline_Event_Type(3);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_Async_Begin: Dart_Timeline_Event_Type =
	Dart_Timeline_Event_Type(4);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_Async_End: Dart_Timeline_Event_Type =
	Dart_Timeline_Event_Type(5);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_Async_Instant: Dart_Timeline_Event_Type =
	Dart_Timeline_Event_Type(6);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_Counter: Dart_Timeline_Event_Type = Dart_Timeline_Event_Type(7);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_Flow_Begin: Dart_Timeline_Event_Type =
	Dart_Timeline_Event_Type(8);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_Flow_Step: Dart_Timeline_Event_Type =
	Dart_Timeline_Event_Type(9);
pub const Dart_Timeline_Event_Type_Dart_Timeline_Event_Flow_End: Dart_Timeline_Event_Type =
	Dart_Timeline_Event_Type(10);
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
	pub __mbstate8: [::core::ffi::c_char; 128usize],
	pub _mbstateL: ::core::ffi::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Dart_NativeArgument_Value {
	pub as_bool: bool,
	pub as_int32: i32,
	pub as_uint32: u32,
	pub as_int64: i64,
	pub as_uint64: u64,
	pub as_double: f64,
	pub as_string: _Dart_NativeArgument_Value__bindgen_ty_1,
	pub as_native_fields: _Dart_NativeArgument_Value__bindgen_ty_2,
	pub as_instance: Dart_Handle,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Dart_CObject__bindgen_ty_1 {
	pub as_bool: bool,
	pub as_int32: i32,
	pub as_int64: i64,
	pub as_double: f64,
	pub as_string: *const ::core::ffi::c_char,
	pub as_send_port: _Dart_CObject__bindgen_ty_1__bindgen_ty_1,
	pub as_capability: _Dart_CObject__bindgen_ty_1__bindgen_ty_2,
	pub as_array: _Dart_CObject__bindgen_ty_1__bindgen_ty_3,
	pub as_typed_data: _Dart_CObject__bindgen_ty_1__bindgen_ty_4,
	pub as_external_typed_data: _Dart_CObject__bindgen_ty_1__bindgen_ty_5,
	pub as_native_pointer: _Dart_CObject__bindgen_ty_1__bindgen_ty_6,
}
extern "C" {
	pub fn __assert_rtn(
		arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char, arg3: ::core::ffi::c_int,
		arg4: *const ::core::ffi::c_char,
	) -> !;
}
extern "C" {
	pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
	pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
	pub fn strtoimax(
		__nptr: *const ::core::ffi::c_char, __endptr: *mut *mut ::core::ffi::c_char, __base: ::core::ffi::c_int,
	) -> intmax_t;
}
extern "C" {
	pub fn strtoumax(
		__nptr: *const ::core::ffi::c_char, __endptr: *mut *mut ::core::ffi::c_char, __base: ::core::ffi::c_int,
	) -> uintmax_t;
}
extern "C" {
	pub fn wcstoimax(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t, __base: ::core::ffi::c_int) -> intmax_t;
}
extern "C" {
	pub fn wcstoumax(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t, __base: ::core::ffi::c_int) -> uintmax_t;
}
extern "C" {
	#[doc = " Is this an error handle?\n\n Requires there to be a current isolate."]
	pub fn Dart_IsError(handle: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Is this an api error handle?\n\n Api error handles are produced when an api function is misused.\n This happens when a Dart embedding api function is called with\n invalid arguments or in an invalid context.\n\n Requires there to be a current isolate."]
	pub fn Dart_IsApiError(handle: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Is this an unhandled exception error handle?\n\n Unhandled exception error handles are produced when, during the\n execution of Dart code, an exception is thrown but not caught.\n This can occur in any function which triggers the execution of Dart\n code.\n\n See Dart_ErrorGetException and Dart_ErrorGetStackTrace.\n\n Requires there to be a current isolate."]
	pub fn Dart_IsUnhandledExceptionError(handle: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Is this a compilation error handle?\n\n Compilation error handles are produced when, during the execution\n of Dart code, a compile-time error occurs.  This can occur in any\n function which triggers the execution of Dart code.\n\n Requires there to be a current isolate."]
	pub fn Dart_IsCompilationError(handle: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Is this a fatal error handle?\n\n Fatal error handles are produced when the system wants to shut down\n the current isolate.\n\n Requires there to be a current isolate."]
	pub fn Dart_IsFatalError(handle: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Gets the error message from an error handle.\n\n Requires there to be a current isolate.\n\n \\return A C string containing an error message if the handle is\n   error. An empty C string (\"\") if the handle is valid. This C\n   String is scope allocated and is only valid until the next call\n   to Dart_ExitScope."]
	pub fn Dart_GetError(handle: Dart_Handle) -> *const ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Is this an error handle for an unhandled exception?"]
	pub fn Dart_ErrorHasException(handle: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Gets the exception Object from an unhandled exception error handle."]
	pub fn Dart_ErrorGetException(handle: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the stack trace Object from an unhandled exception error handle."]
	pub fn Dart_ErrorGetStackTrace(handle: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Produces an api error handle with the provided error message.\n\n Requires there to be a current isolate.\n\n \\param error the error message."]
	pub fn Dart_NewApiError(error: *const ::core::ffi::c_char) -> Dart_Handle;
}
extern "C" {
	pub fn Dart_NewCompilationError(error: *const ::core::ffi::c_char) -> Dart_Handle;
}
extern "C" {
	#[doc = " Produces a new unhandled exception error handle.\n\n Requires there to be a current isolate.\n\n \\param exception An instance of a Dart object to be thrown or\n        an ApiError or CompilationError handle.\n        When an ApiError or CompilationError handle is passed in\n        a string object of the error message is created and it becomes\n        the Dart object to be thrown."]
	pub fn Dart_NewUnhandledExceptionError(exception: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Propagates an error.\n\n If the provided handle is an unhandled exception error, this\n function will cause the unhandled exception to be rethrown.  This\n will proceed in the standard way, walking up Dart frames until an\n appropriate 'catch' block is found, executing 'finally' blocks,\n etc.\n\n If the error is not an unhandled exception error, we will unwind\n the stack to the next C frame.  Intervening Dart frames will be\n discarded; specifically, 'finally' blocks will not execute.  This\n is the standard way that compilation errors (and the like) are\n handled by the Dart runtime.\n\n In either case, when an error is propagated any current scopes\n created by Dart_EnterScope will be exited.\n\n See the additional discussion under \"Propagating Errors\" at the\n beginning of this file.\n\n \\param handle An error handle (See Dart_IsError)\n\n On success, this function does not return.  On failure, the\n process is terminated."]
	pub fn Dart_PropagateError(handle: Dart_Handle);
}
extern "C" {
	#[doc = " Converts an object to a string.\n\n May generate an unhandled exception error.\n\n \\return The converted string if no error occurs during\n   the conversion. If an error does occur, an error handle is\n   returned."]
	pub fn Dart_ToString(object: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Checks to see if two handles refer to identically equal objects.\n\n If both handles refer to instances, this is equivalent to using the top-level\n function identical() from dart:core. Otherwise, returns whether the two\n argument handles refer to the same object.\n\n \\param obj1 An object to be compared.\n \\param obj2 An object to be compared.\n\n \\return True if the objects are identically equal.  False otherwise."]
	pub fn Dart_IdentityEquals(obj1: Dart_Handle, obj2: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Allocates a handle in the current scope from a persistent handle."]
	pub fn Dart_HandleFromPersistent(object: Dart_PersistentHandle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Allocates a handle in the current scope from a weak persistent handle.\n\n This will be a handle to Dart_Null if the object has been garbage collected."]
	pub fn Dart_HandleFromWeakPersistent(object: Dart_WeakPersistentHandle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Allocates a persistent handle for an object.\n\n This handle has the lifetime of the current isolate unless it is\n explicitly deallocated by calling Dart_DeletePersistentHandle.\n\n Requires there to be a current isolate."]
	pub fn Dart_NewPersistentHandle(object: Dart_Handle) -> Dart_PersistentHandle;
}
extern "C" {
	#[doc = " Assign value of local handle to a persistent handle.\n\n Requires there to be a current isolate.\n\n \\param obj1 A persistent handle whose value needs to be set.\n \\param obj2 An object whose value needs to be set to the persistent handle."]
	pub fn Dart_SetPersistentHandle(obj1: Dart_PersistentHandle, obj2: Dart_Handle);
}
extern "C" {
	#[doc = " Deallocates a persistent handle.\n\n Requires there to be a current isolate group."]
	pub fn Dart_DeletePersistentHandle(object: Dart_PersistentHandle);
}
extern "C" {
	#[doc = " Allocates a weak persistent handle for an object.\n\n This handle has the lifetime of the current isolate. The handle can also be\n explicitly deallocated by calling Dart_DeleteWeakPersistentHandle.\n\n If the object becomes unreachable the callback is invoked with the peer as\n argument. The callback can be executed on any thread, will have a current\n isolate group, but will not have a current isolate. The callback can only\n call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle. This\n gives the embedder the ability to cleanup data associated with the object.\n The handle will point to the Dart_Null object after the finalizer has been\n run. It is illegal to call into the VM with any other Dart_* functions from\n the callback. If the handle is deleted before the object becomes\n unreachable, the callback is never invoked.\n\n Requires there to be a current isolate.\n\n \\param object An object with identity.\n \\param peer A pointer to a native object or NULL.  This value is\n   provided to callback when it is invoked.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A function pointer that will be invoked sometime\n   after the object is garbage collected, unless the handle has been deleted.\n   A valid callback needs to be specified it cannot be NULL.\n\n \\return The weak persistent handle or NULL. NULL is returned in case of bad\n   parameters."]
	pub fn Dart_NewWeakPersistentHandle(
		object: Dart_Handle, peer: *mut ::core::ffi::c_void, external_allocation_size: isize,
		callback: Dart_HandleFinalizer,
	) -> Dart_WeakPersistentHandle;
}
extern "C" {
	#[doc = " Deletes the given weak persistent [object] handle.\n\n Requires there to be a current isolate group."]
	pub fn Dart_DeleteWeakPersistentHandle(object: Dart_WeakPersistentHandle);
}
extern "C" {
	#[doc = " Allocates a finalizable handle for an object.\n\n This handle has the lifetime of the current isolate group unless the object\n pointed to by the handle is garbage collected, in this case the VM\n automatically deletes the handle after invoking the callback associated\n with the handle. The handle can also be explicitly deallocated by\n calling Dart_DeleteFinalizableHandle.\n\n If the object becomes unreachable the callback is invoked with the\n the peer as argument. The callback can be executed on any thread, will have\n an isolate group, but will not have a current isolate. The callback can only\n call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle.\n This gives the embedder the ability to cleanup data associated with the\n object and clear out any cached references to the handle. All references to\n this handle after the callback will be invalid. It is illegal to call into\n the VM with any other Dart_* functions from the callback. If the handle is\n deleted before the object becomes unreachable, the callback is never\n invoked.\n\n Requires there to be a current isolate.\n\n \\param object An object with identity.\n \\param peer A pointer to a native object or NULL.  This value is\n   provided to callback when it is invoked.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A function pointer that will be invoked sometime\n   after the object is garbage collected, unless the handle has been deleted.\n   A valid callback needs to be specified it cannot be NULL.\n\n \\return The finalizable handle or NULL. NULL is returned in case of bad\n   parameters."]
	pub fn Dart_NewFinalizableHandle(
		object: Dart_Handle, peer: *mut ::core::ffi::c_void, external_allocation_size: isize,
		callback: Dart_HandleFinalizer,
	) -> Dart_FinalizableHandle;
}
extern "C" {
	#[doc = " Deletes the given finalizable [object] handle.\n\n The caller has to provide the actual Dart object the handle was created from\n to prove the object (and therefore the finalizable handle) is still alive.\n\n Requires there to be a current isolate."]
	pub fn Dart_DeleteFinalizableHandle(object: Dart_FinalizableHandle, strong_ref_to_object: Dart_Handle);
}
extern "C" {
	#[doc = " Gets the version string for the Dart VM.\n\n The version of the Dart VM can be accessed without initializing the VM.\n\n \\return The version string for the embedded Dart VM."]
	pub fn Dart_VersionString() -> *const ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Initialize Dart_IsolateFlags with correct version and default values."]
	pub fn Dart_IsolateFlagsInitialize(flags: *mut Dart_IsolateFlags);
}
extern "C" {
	#[doc = " Initializes the VM.\n\n \\param params A struct containing initialization information. The version\n   field of the struct must be DART_INITIALIZE_PARAMS_CURRENT_VERSION.\n\n \\return NULL if initialization is successful. Returns an error message\n   otherwise. The caller is responsible for freeing the error message."]
	pub fn Dart_Initialize(params: *mut Dart_InitializeParams) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Cleanup state in the VM before process termination.\n\n \\return NULL if cleanup is successful. Returns an error message otherwise.\n   The caller is responsible for freeing the error message.\n\n NOTE: This function must not be called on a thread that was created by the VM\n itself."]
	pub fn Dart_Cleanup() -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Sets command line flags. Should be called before Dart_Initialize.\n\n \\param argc The length of the arguments array.\n \\param argv An array of arguments.\n\n \\return NULL if successful. Returns an error message otherwise.\n  The caller is responsible for freeing the error message.\n\n NOTE: This call does not store references to the passed in c-strings."]
	pub fn Dart_SetVMFlags(argc: ::core::ffi::c_int, argv: *mut *const ::core::ffi::c_char)
	-> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Returns true if the named VM flag is of boolean type, specified, and set to\n true.\n\n \\param flag_name The name of the flag without leading punctuation\n                  (example: \"enable_asserts\")."]
	pub fn Dart_IsVMFlagSet(flag_name: *const ::core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Creates a new isolate. The new isolate becomes the current isolate.\n\n A snapshot can be used to restore the VM quickly to a saved state\n and is useful for fast startup. If snapshot data is provided, the\n isolate will be started using that snapshot data. Requires a core snapshot or\n an app snapshot created by Dart_CreateSnapshot or\n Dart_CreatePrecompiledSnapshot* from a VM with the same version.\n\n Requires there to be no current isolate.\n\n \\param script_uri The main source file or snapshot this isolate will load.\n   The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a\n   child isolate is created by Isolate.spawn. The embedder should use a URI\n   that allows it to load the same program into such a child isolate.\n \\param name A short name for the isolate to improve debugging messages.\n   Typically of the format 'foo.dart:main()'.\n \\param isolate_snapshot_data Buffer containing the snapshot data of the\n   isolate or NULL if no snapshot is provided. If provided, the buffer must\n   remain valid until the isolate shuts down.\n \\param isolate_snapshot_instructions Buffer containing the snapshot\n   instructions of the isolate or NULL if no snapshot is provided. If\n   provided, the buffer must remain valid until the isolate shuts down.\n \\param flags Pointer to VM specific flags or NULL for default flags.\n \\param isolate_group_data Embedder group data. This data can be obtained\n   by calling Dart_IsolateGroupData and will be passed to the\n   Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and\n   Dart_IsolateGroupCleanupCallback.\n \\param isolate_data Embedder data.  This data will be passed to\n   the Dart_IsolateGroupCreateCallback when new isolates are spawned from\n   this parent isolate.\n \\param error Returns NULL if creation is successful, an error message\n   otherwise. The caller is responsible for calling free() on the error\n   message.\n\n \\return The new isolate on success, or NULL if isolate creation failed."]
	pub fn Dart_CreateIsolateGroup(
		script_uri: *const ::core::ffi::c_char, name: *const ::core::ffi::c_char, isolate_snapshot_data: *const u8,
		isolate_snapshot_instructions: *const u8, flags: *mut Dart_IsolateFlags,
		isolate_group_data: *mut ::core::ffi::c_void, isolate_data: *mut ::core::ffi::c_void,
		error: *mut *mut ::core::ffi::c_char,
	) -> Dart_Isolate;
}
extern "C" {
	#[doc = " Creates a new isolate inside the isolate group of [group_member].\n\n Requires there to be no current isolate.\n\n \\param group_member An isolate from the same group into which the newly created\n   isolate should be born into. Other threads may not have entered / enter this\n   member isolate.\n \\param name A short name for the isolate for debugging purposes.\n \\param shutdown_callback A callback to be called when the isolate is being\n   shutdown (may be NULL).\n \\param cleanup_callback A callback to be called when the isolate is being\n   cleaned up (may be NULL).\n \\param child_isolate_data The embedder-specific data associated with this isolate.\n \\param error Set to NULL if creation is successful, set to an error\n   message otherwise. The caller is responsible for calling free() on the\n   error message.\n\n \\return The newly created isolate on success, or NULL if isolate creation\n   failed.\n\n If successful, the newly created isolate will become the current isolate."]
	pub fn Dart_CreateIsolateInGroup(
		group_member: Dart_Isolate, name: *const ::core::ffi::c_char, shutdown_callback: Dart_IsolateShutdownCallback,
		cleanup_callback: Dart_IsolateCleanupCallback, child_isolate_data: *mut ::core::ffi::c_void,
		error: *mut *mut ::core::ffi::c_char,
	) -> Dart_Isolate;
}
extern "C" {
	#[doc = " Creates a new isolate from a Dart Kernel file. The new isolate\n becomes the current isolate.\n\n Requires there to be no current isolate.\n\n \\param script_uri The main source file or snapshot this isolate will load.\n   The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a\n child isolate is created by Isolate.spawn. The embedder should use a URI that\n   allows it to load the same program into such a child isolate.\n \\param name A short name for the isolate to improve debugging messages.\n   Typically of the format 'foo.dart:main()'.\n \\param kernel_buffer A buffer which contains a kernel/DIL program. Must\n   remain valid until isolate shutdown.\n \\param kernel_buffer_size The size of `kernel_buffer`.\n \\param flags Pointer to VM specific flags or NULL for default flags.\n \\param isolate_group_data Embedder group data. This data can be obtained\n   by calling Dart_IsolateGroupData and will be passed to the\n   Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and\n   Dart_IsolateGroupCleanupCallback.\n \\param isolate_data Embedder data.  This data will be passed to\n   the Dart_IsolateGroupCreateCallback when new isolates are spawned from\n   this parent isolate.\n \\param error Returns NULL if creation is successful, an error message\n   otherwise. The caller is responsible for calling free() on the error\n   message.\n\n \\return The new isolate on success, or NULL if isolate creation failed."]
	pub fn Dart_CreateIsolateGroupFromKernel(
		script_uri: *const ::core::ffi::c_char, name: *const ::core::ffi::c_char, kernel_buffer: *const u8,
		kernel_buffer_size: isize, flags: *mut Dart_IsolateFlags, isolate_group_data: *mut ::core::ffi::c_void,
		isolate_data: *mut ::core::ffi::c_void, error: *mut *mut ::core::ffi::c_char,
	) -> Dart_Isolate;
}
extern "C" {
	#[doc = " Shuts down the current isolate. After this call, the current isolate is NULL.\n Any current scopes created by Dart_EnterScope will be exited. Invokes the\n shutdown callback and any callbacks of remaining weak persistent handles.\n\n Requires there to be a current isolate."]
	pub fn Dart_ShutdownIsolate();
}
extern "C" {
	#[doc = " Returns the current isolate. Will return NULL if there is no\n current isolate."]
	pub fn Dart_CurrentIsolate() -> Dart_Isolate;
}
extern "C" {
	#[doc = " Returns the callback data associated with the current isolate. This\n data was set when the isolate got created or initialized."]
	pub fn Dart_CurrentIsolateData() -> *mut ::core::ffi::c_void;
}
extern "C" {
	#[doc = " Returns the callback data associated with the given isolate. This\n data was set when the isolate got created or initialized."]
	pub fn Dart_IsolateData(isolate: Dart_Isolate) -> *mut ::core::ffi::c_void;
}
extern "C" {
	#[doc = " Returns the current isolate group. Will return NULL if there is no\n current isolate group."]
	pub fn Dart_CurrentIsolateGroup() -> Dart_IsolateGroup;
}
extern "C" {
	#[doc = " Returns the callback data associated with the current isolate group. This\n data was passed to the isolate group when it was created."]
	pub fn Dart_CurrentIsolateGroupData() -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn Dart_CurrentIsolateGroupId() -> Dart_IsolateGroupId;
}
extern "C" {
	#[doc = " Returns the callback data associated with the specified isolate group. This\n data was passed to the isolate when it was created.\n The embedder is responsible for ensuring the consistency of this data\n with respect to the lifecycle of an isolate group."]
	pub fn Dart_IsolateGroupData(isolate: Dart_Isolate) -> *mut ::core::ffi::c_void;
}
extern "C" {
	#[doc = " Returns the debugging name for the current isolate.\n\n This name is unique to each isolate and should only be used to make\n debugging messages more comprehensible."]
	pub fn Dart_DebugName() -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns the debugging name for the current isolate.\n\n This name is unique to each isolate and should only be used to make\n debugging messages more comprehensible.\n\n The returned string is scope allocated and is only valid until the next call\n to Dart_ExitScope."]
	pub fn Dart_DebugNameToCString() -> *const ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Returns the ID for an isolate which is used to query the service protocol.\n\n It is the responsibility of the caller to free the returned ID."]
	pub fn Dart_IsolateServiceId(isolate: Dart_Isolate) -> *const ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Enters an isolate. After calling this function,\n the current isolate will be set to the provided isolate.\n\n Requires there to be no current isolate. Multiple threads may not be in\n the same isolate at once."]
	pub fn Dart_EnterIsolate(isolate: Dart_Isolate);
}
extern "C" {
	#[doc = " Kills the given isolate.\n\n This function has the same effect as dart:isolate's\n Isolate.kill(priority:immediate).\n It can interrupt ordinary Dart code but not native code. If the isolate is\n in the middle of a long running native function, the isolate will not be\n killed until control returns to Dart.\n\n Does not require a current isolate. It is safe to kill the current isolate if\n there is one."]
	pub fn Dart_KillIsolate(isolate: Dart_Isolate);
}
extern "C" {
	#[doc = " Notifies the VM that the embedder expects to be idle until |deadline|. The VM\n may use this time to perform garbage collection or other tasks to avoid\n delays during execution of Dart code in the future.\n\n |deadline| is measured in microseconds against the system's monotonic time.\n This clock can be accessed via Dart_TimelineGetMicros().\n\n Requires there to be a current isolate."]
	pub fn Dart_NotifyIdle(deadline: i64);
}
extern "C" {
	#[doc = " Starts the heap sampling profiler for each thread in the VM."]
	pub fn Dart_EnableHeapSampling();
}
extern "C" {
	pub fn Dart_DisableHeapSampling();
}
extern "C" {
	pub fn Dart_RegisterHeapSamplingCallback(
		create_callback: Dart_HeapSamplingCreateCallback, delete_callback: Dart_HeapSamplingDeleteCallback,
	);
}
extern "C" {
	pub fn Dart_ReportSurvivingAllocations(
		callback: Dart_HeapSamplingReportCallback, context: *mut ::core::ffi::c_void, force_gc: bool,
	);
}
extern "C" {
	pub fn Dart_SetHeapSamplingPeriod(bytes: isize);
}
extern "C" {
	#[doc = " Notifies the VM that the embedder expects the application's working set has\n recently shrunk significantly and is not expected to rise in the near future.\n The VM may spend O(heap-size) time performing clean up work.\n\n Requires there to be a current isolate."]
	pub fn Dart_NotifyDestroyed();
}
extern "C" {
	#[doc = " Notifies the VM that the system is running low on memory.\n\n Does not require a current isolate. Only valid after calling Dart_Initialize."]
	pub fn Dart_NotifyLowMemory();
}
extern "C" {
	#[doc = " Set the desired performance trade-off.\n\n Requires a current isolate.\n\n Returns the previous performance mode."]
	pub fn Dart_SetPerformanceMode(mode: Dart_PerformanceMode) -> Dart_PerformanceMode;
}
extern "C" {
	#[doc = " Starts the CPU sampling profiler."]
	pub fn Dart_StartProfiling();
}
extern "C" {
	#[doc = " Stops the CPU sampling profiler.\n\n Note that some profile samples might still be taken after this function\n returns due to the asynchronous nature of the implementation on some\n platforms."]
	pub fn Dart_StopProfiling();
}
extern "C" {
	#[doc = " Notifies the VM that the current thread should not be profiled until a\n matching call to Dart_ThreadEnableProfiling is made.\n\n NOTE: By default, if a thread has entered an isolate it will be profiled.\n This function should be used when an embedder knows a thread is about\n to make a blocking call and wants to avoid unnecessary interrupts by\n the profiler."]
	pub fn Dart_ThreadDisableProfiling();
}
extern "C" {
	#[doc = " Notifies the VM that the current thread should be profiled.\n\n NOTE: It is only legal to call this function *after* calling\n   Dart_ThreadDisableProfiling.\n\n NOTE: By default, if a thread has entered an isolate it will be profiled."]
	pub fn Dart_ThreadEnableProfiling();
}
extern "C" {
	#[doc = " Register symbol information for the Dart VM's profiler and crash dumps.\n\n This consumes the output of //topaz/runtime/dart/profiler_symbols, which\n should be treated as opaque."]
	pub fn Dart_AddSymbols(dso_name: *const ::core::ffi::c_char, buffer: *mut ::core::ffi::c_void, buffer_size: isize);
}
extern "C" {
	#[doc = " Exits an isolate. After this call, Dart_CurrentIsolate will\n return NULL.\n\n Requires there to be a current isolate."]
	pub fn Dart_ExitIsolate();
}
extern "C" {
	#[doc = " Creates a full snapshot of the current isolate heap.\n\n A full snapshot is a compact representation of the dart vm isolate heap\n and dart isolate heap states. These snapshots are used to initialize\n the vm isolate on startup and fast initialization of an isolate.\n A Snapshot of the heap is created before any dart code has executed.\n\n Requires there to be a current isolate. Not available in the precompiled\n runtime (check Dart_IsPrecompiledRuntime).\n\n \\param vm_snapshot_data_buffer Returns a pointer to a buffer containing the\n   vm snapshot. This buffer is scope allocated and is only valid\n   until the next call to Dart_ExitScope.\n \\param vm_snapshot_data_size Returns the size of vm_snapshot_data_buffer.\n \\param isolate_snapshot_data_buffer Returns a pointer to a buffer containing\n   the isolate snapshot. This buffer is scope allocated and is only valid\n   until the next call to Dart_ExitScope.\n \\param isolate_snapshot_data_size Returns the size of\n   isolate_snapshot_data_buffer.\n \\param is_core Create a snapshot containing core libraries.\n   Such snapshot should be agnostic to null safety mode.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_CreateSnapshot(
		vm_snapshot_data_buffer: *mut *mut u8, vm_snapshot_data_size: *mut isize,
		isolate_snapshot_data_buffer: *mut *mut u8, isolate_snapshot_data_size: *mut isize, is_core: bool,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns whether the buffer contains a kernel file.\n\n \\param buffer Pointer to a buffer that might contain a kernel binary.\n \\param buffer_size Size of the buffer.\n\n \\return Whether the buffer contains a kernel binary (full or partial)."]
	pub fn Dart_IsKernel(buffer: *const u8, buffer_size: isize) -> bool;
}
extern "C" {
	#[doc = " Make isolate runnable.\n\n When isolates are spawned, this function is used to indicate that\n the creation and initialization (including script loading) of the\n isolate is complete and the isolate can start.\n This function expects there to be no current isolate.\n\n \\param isolate The isolate to be made runnable.\n\n \\return NULL if successful. Returns an error message otherwise. The caller\n is responsible for freeing the error message."]
	pub fn Dart_IsolateMakeRunnable(isolate: Dart_Isolate) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Allows embedders to provide a custom wakeup mechanism for the delivery of\n inter-isolate messages. This setting only applies to the current isolate.\n\n This mechanism is optional: if not provided, the isolate will be scheduled on\n a VM-managed thread pool. An embedder should provide this callback if it\n wants to run an isolate on a specific thread or to interleave handling of\n inter-isolate messages with other event sources.\n\n Most embedders will only call this function once, before isolate\n execution begins. If this function is called after isolate\n execution begins, the embedder is responsible for threading issues."]
	pub fn Dart_SetMessageNotifyCallback(message_notify_callback: Dart_MessageNotifyCallback);
}
extern "C" {
	#[doc = " Query the current message notify callback for the isolate.\n\n \\return The current message notify callback for the isolate."]
	pub fn Dart_GetMessageNotifyCallback() -> Dart_MessageNotifyCallback;
}
extern "C" {
	#[doc = " If the VM flag `--pause-isolates-on-start` was passed this will be true.\n\n \\return A boolean value indicating if pause on start was requested."]
	pub fn Dart_ShouldPauseOnStart() -> bool;
}
extern "C" {
	#[doc = " Override the VM flag `--pause-isolates-on-start` for the current isolate.\n\n \\param should_pause Should the isolate be paused on start?\n\n NOTE: This must be called before Dart_IsolateMakeRunnable."]
	pub fn Dart_SetShouldPauseOnStart(should_pause: bool);
}
extern "C" {
	#[doc = " Is the current isolate paused on start?\n\n \\return A boolean value indicating if the isolate is paused on start."]
	pub fn Dart_IsPausedOnStart() -> bool;
}
extern "C" {
	#[doc = " Called when the embedder has paused the current isolate on start and when\n the embedder has resumed the isolate.\n\n \\param paused Is the isolate paused on start?"]
	pub fn Dart_SetPausedOnStart(paused: bool);
}
extern "C" {
	#[doc = " If the VM flag `--pause-isolates-on-exit` was passed this will be true.\n\n \\return A boolean value indicating if pause on exit was requested."]
	pub fn Dart_ShouldPauseOnExit() -> bool;
}
extern "C" {
	#[doc = " Override the VM flag `--pause-isolates-on-exit` for the current isolate.\n\n \\param should_pause Should the isolate be paused on exit?\n"]
	pub fn Dart_SetShouldPauseOnExit(should_pause: bool);
}
extern "C" {
	#[doc = " Is the current isolate paused on exit?\n\n \\return A boolean value indicating if the isolate is paused on exit."]
	pub fn Dart_IsPausedOnExit() -> bool;
}
extern "C" {
	#[doc = " Called when the embedder has paused the current isolate on exit and when\n the embedder has resumed the isolate.\n\n \\param paused Is the isolate paused on exit?"]
	pub fn Dart_SetPausedOnExit(paused: bool);
}
extern "C" {
	#[doc = " Called when the embedder has caught a top level unhandled exception error\n in the current isolate.\n\n NOTE: It is illegal to call this twice on the same isolate without first\n clearing the sticky error to null.\n\n \\param error The unhandled exception error."]
	pub fn Dart_SetStickyError(error: Dart_Handle);
}
extern "C" {
	#[doc = " Does the current isolate have a sticky error?"]
	pub fn Dart_HasStickyError() -> bool;
}
extern "C" {
	#[doc = " Gets the sticky error for the current isolate.\n\n \\return A handle to the sticky error object or null."]
	pub fn Dart_GetStickyError() -> Dart_Handle;
}
extern "C" {
	#[doc = " Handles the next pending message for the current isolate.\n\n May generate an unhandled exception error.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_HandleMessage() -> Dart_Handle;
}
extern "C" {
	#[doc = " Handles any pending messages for the vm service for the current\n isolate.\n\n This function may be used by an embedder at a breakpoint to avoid\n pausing the vm service.\n\n This function can indirectly cause the message notify callback to\n be called.\n\n \\return true if the vm service requests the program resume\n execution, false otherwise"]
	pub fn Dart_HandleServiceMessages() -> bool;
}
extern "C" {
	#[doc = " Does the current isolate have pending service messages?\n\n \\return true if the isolate has pending service messages, false otherwise."]
	pub fn Dart_HasServiceMessages() -> bool;
}
extern "C" {
	#[doc = " Processes any incoming messages for the current isolate.\n\n This function may only be used when the embedder has not provided\n an alternate message delivery mechanism with\n Dart_SetMessageCallbacks. It is provided for convenience.\n\n This function waits for incoming messages for the current\n isolate. As new messages arrive, they are handled using\n Dart_HandleMessage. The routine exits when all ports to the\n current isolate are closed.\n\n \\return A valid handle if the run loop exited successfully.  If an\n   exception or other error occurs while processing messages, an\n   error handle is returned."]
	pub fn Dart_RunLoop() -> Dart_Handle;
}
extern "C" {
	#[doc = " Lets the VM run message processing for the isolate.\n\n This function expects there to a current isolate and the current isolate\n must not have an active api scope. The VM will take care of making the\n isolate runnable (if not already), handles its message loop and will take\n care of shutting the isolate down once it's done.\n\n \\param errors_are_fatal Whether uncaught errors should be fatal.\n \\param on_error_port A port to notify on uncaught errors (or ILLEGAL_PORT).\n \\param on_exit_port A port to notify on exit (or ILLEGAL_PORT).\n \\param error A non-NULL pointer which will hold an error message if the call\n   fails. The error has to be free()ed by the caller.\n\n \\return If successful the VM takes ownership of the isolate and takes care\n   of its message loop. If not successful the caller retains ownership of the\n   isolate."]
	pub fn Dart_RunLoopAsync(
		errors_are_fatal: bool, on_error_port: Dart_Port, on_exit_port: Dart_Port, error: *mut *mut ::core::ffi::c_char,
	) -> bool;
}
extern "C" {
	#[doc = " Gets the main port id for the current isolate."]
	pub fn Dart_GetMainPortId() -> Dart_Port;
}
extern "C" {
	#[doc = " Does the current isolate have live ReceivePorts?\n\n A ReceivePort is live when it has not been closed."]
	pub fn Dart_HasLivePorts() -> bool;
}
extern "C" {
	#[doc = " Posts a message for some isolate. The message is a serialized\n object.\n\n Requires there to be a current isolate.\n\n For posting messages outside of an isolate see \\ref Dart_PostCObject.\n\n \\param port_id The destination port.\n \\param object An object from the current isolate.\n\n \\return True if the message was posted."]
	pub fn Dart_Post(port_id: Dart_Port, object: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Returns a new SendPort with the provided port id.\n\n If there is a possibility of a port closing since port_id was acquired\n for a SendPort, one should use Dart_NewSendPortEx and\n Dart_SendPortGetIdEx.\n\n \\param port_id The destination port.\n\n \\return A new SendPort if no errors occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewSendPort(port_id: Dart_Port) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a new SendPort with the provided port id and origin id.\n\n \\param portex_id The destination composte port id.\n\n \\return A new SendPort if no errors occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewSendPortEx(portex_id: Dart_PortEx) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the SendPort id for the provided SendPort.\n \\param port A SendPort object whose id is desired.\n \\param port_id Returns the id of the SendPort.\n \\return Success if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_SendPortGetId(port: Dart_Handle, port_id: *mut Dart_Port) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the SendPort and Origin ids for the provided SendPort.\n \\param port A SendPort object whose id is desired.\n \\param portex_id Returns composite id of the SendPort.\n \\return Success if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_SendPortGetIdEx(port: Dart_Handle, portex_id: *mut Dart_PortEx) -> Dart_Handle;
}
extern "C" {
	#[doc = " Enters a new scope.\n\n All new local handles will be created in this scope. Additionally,\n some functions may return \"scope allocated\" memory which is only\n valid within this scope.\n\n Requires there to be a current isolate."]
	pub fn Dart_EnterScope();
}
extern "C" {
	#[doc = " Exits a scope.\n\n The previous scope (if any) becomes the current scope.\n\n Requires there to be a current isolate."]
	pub fn Dart_ExitScope();
}
extern "C" {
	#[doc = " The Dart VM uses \"zone allocation\" for temporary structures. Zones\n support very fast allocation of small chunks of memory. The chunks\n cannot be deallocated individually, but instead zones support\n deallocating all chunks in one fast operation.\n\n This function makes it possible for the embedder to allocate\n temporary data in the VMs zone allocator.\n\n Zone allocation is possible:\n   1. when inside a scope where local handles can be allocated\n   2. when processing a message from a native port in a native port\n      handler\n\n All the memory allocated this way will be reclaimed either on the\n next call to Dart_ExitScope or when the native port handler exits.\n\n \\param size Size of the memory to allocate.\n\n \\return A pointer to the allocated memory. NULL if allocation\n   failed. Failure might due to is no current VM zone."]
	pub fn Dart_ScopeAllocate(size: isize) -> *mut u8;
}
extern "C" {
	#[doc = " Returns the null object.\n\n \\return A handle to the null object."]
	pub fn Dart_Null() -> Dart_Handle;
}
extern "C" {
	#[doc = " Is this object null?"]
	pub fn Dart_IsNull(object: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Returns the empty string object.\n\n \\return A handle to the empty string object."]
	pub fn Dart_EmptyString() -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns types that are not classes, and which therefore cannot be looked up\n as library members by Dart_GetType.\n\n \\return A handle to the dynamic, void or Never type."]
	pub fn Dart_TypeDynamic() -> Dart_Handle;
}
extern "C" {
	pub fn Dart_TypeVoid() -> Dart_Handle;
}
extern "C" {
	pub fn Dart_TypeNever() -> Dart_Handle;
}
extern "C" {
	#[doc = " Checks if the two objects are equal.\n\n The result of the comparison is returned through the 'equal'\n parameter. The return value itself is used to indicate success or\n failure, not equality.\n\n May generate an unhandled exception error.\n\n \\param obj1 An object to be compared.\n \\param obj2 An object to be compared.\n \\param equal Returns the result of the equality comparison.\n\n \\return A valid handle if no error occurs during the comparison."]
	pub fn Dart_ObjectEquals(obj1: Dart_Handle, obj2: Dart_Handle, equal: *mut bool) -> Dart_Handle;
}
extern "C" {
	#[doc = " Is this object an instance of some type?\n\n The result of the test is returned through the 'instanceof' parameter.\n The return value itself is used to indicate success or failure.\n\n \\param object An object.\n \\param type A type.\n \\param instanceof Return true if 'object' is an instance of type 'type'.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_ObjectIsType(object: Dart_Handle, type_: Dart_Handle, instanceof: *mut bool) -> Dart_Handle;
}
extern "C" {
	#[doc = " Query object type.\n\n \\param object Some Object.\n\n \\return true if Object is of the specified type."]
	pub fn Dart_IsInstance(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsNumber(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsInteger(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsDouble(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsBoolean(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsString(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsStringLatin1(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsList(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsMap(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsLibrary(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsType(handle: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsFunction(handle: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsVariable(handle: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsTypeVariable(handle: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsClosure(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsTypedData(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsByteBuffer(object: Dart_Handle) -> bool;
}
extern "C" {
	pub fn Dart_IsFuture(object: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Gets the type of a Dart language object.\n\n \\param instance Some Dart object.\n\n \\return If no error occurs, the type is returned. Otherwise an\n   error handle is returned."]
	pub fn Dart_InstanceGetType(instance: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns the name for the provided class type.\n\n \\return A valid string handle if no error occurs during the\n   operation."]
	pub fn Dart_ClassName(cls_type: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns the name for the provided function or method.\n\n \\return A valid string handle if no error occurs during the\n   operation."]
	pub fn Dart_FunctionName(function: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a handle to the owner of a function.\n\n The owner of an instance method or a static method is its defining\n class. The owner of a top-level function is its defining\n library. The owner of the function of a non-implicit closure is the\n function of the method or closure that defines the non-implicit\n closure.\n\n \\return A valid handle to the owner of the function, or an error\n   handle if the argument is not a valid handle to a function."]
	pub fn Dart_FunctionOwner(function: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Determines whether a function handle refers to a static function\n of method.\n\n For the purposes of the embedding API, a top-level function is\n implicitly declared static.\n\n \\param function A handle to a function or method declaration.\n \\param is_static Returns whether the function or method is declared static.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_FunctionIsStatic(function: Dart_Handle, is_static: *mut bool) -> Dart_Handle;
}
extern "C" {
	#[doc = " Is this object a closure resulting from a tear-off (closurized method)?\n\n Returns true for closures produced when an ordinary method is accessed\n through a getter call. Returns false otherwise, in particular for closures\n produced from local function declarations.\n\n \\param object Some Object.\n\n \\return true if Object is a tear-off."]
	pub fn Dart_IsTearOff(object: Dart_Handle) -> bool;
}
extern "C" {
	#[doc = " Retrieves the function of a closure.\n\n \\return A handle to the function of the closure, or an error handle if the\n   argument is not a closure."]
	pub fn Dart_ClosureFunction(closure: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a handle to the library which contains class.\n\n \\return A valid handle to the library with owns class, null if the class\n   has no library or an error handle if the argument is not a valid handle\n   to a class type."]
	pub fn Dart_ClassLibrary(cls_type: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Does this Integer fit into a 64-bit signed integer?\n\n \\param integer An integer.\n \\param fits Returns true if the integer fits into a 64-bit signed integer.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_IntegerFitsIntoInt64(integer: Dart_Handle, fits: *mut bool) -> Dart_Handle;
}
extern "C" {
	#[doc = " Does this Integer fit into a 64-bit unsigned integer?\n\n \\param integer An integer.\n \\param fits Returns true if the integer fits into a 64-bit unsigned integer.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_IntegerFitsIntoUint64(integer: Dart_Handle, fits: *mut bool) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns an Integer with the provided value.\n\n \\param value The value of the integer.\n\n \\return The Integer object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewInteger(value: i64) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns an Integer with the provided value.\n\n \\param value The unsigned value of the integer.\n\n \\return The Integer object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewIntegerFromUint64(value: u64) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns an Integer with the provided value.\n\n \\param value The value of the integer represented as a C string\n   containing a hexadecimal number.\n\n \\return The Integer object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewIntegerFromHexCString(value: *const ::core::ffi::c_char) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the value of an Integer.\n\n The integer must fit into a 64-bit signed integer, otherwise an error occurs.\n\n \\param integer An Integer.\n \\param value Returns the value of the Integer.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_IntegerToInt64(integer: Dart_Handle, value: *mut i64) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the value of an Integer.\n\n The integer must fit into a 64-bit unsigned integer, otherwise an\n error occurs.\n\n \\param integer An Integer.\n \\param value Returns the value of the Integer.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_IntegerToUint64(integer: Dart_Handle, value: *mut u64) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the value of an integer as a hexadecimal C string.\n\n \\param integer An Integer.\n \\param value Returns the value of the Integer as a hexadecimal C\n   string. This C string is scope allocated and is only valid until\n   the next call to Dart_ExitScope.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_IntegerToHexCString(integer: Dart_Handle, value: *mut *const ::core::ffi::c_char) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a Double with the provided value.\n\n \\param value A double.\n\n \\return The Double object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewDouble(value: f64) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the value of a Double\n\n \\param double_obj A Double\n \\param value Returns the value of the Double.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_DoubleValue(double_obj: Dart_Handle, value: *mut f64) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a closure of static function 'function_name' in the class 'class_name'\n in the exported namespace of specified 'library'.\n\n \\param library Library object\n \\param cls_type Type object representing a Class\n \\param function_name Name of the static function in the class\n\n \\return A valid Dart instance if no error occurs during the operation."]
	pub fn Dart_GetStaticMethodClosure(
		library: Dart_Handle, cls_type: Dart_Handle, function_name: Dart_Handle,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns the True object.\n\n Requires there to be a current isolate.\n\n \\return A handle to the True object."]
	pub fn Dart_True() -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns the False object.\n\n Requires there to be a current isolate.\n\n \\return A handle to the False object."]
	pub fn Dart_False() -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a Boolean with the provided value.\n\n \\param value true or false.\n\n \\return The Boolean object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewBoolean(value: bool) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the value of a Boolean\n\n \\param boolean_obj A Boolean\n \\param value Returns the value of the Boolean.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_BooleanValue(boolean_obj: Dart_Handle, value: *mut bool) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the length of a String.\n\n \\param str A String.\n \\param length Returns the length of the String.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_StringLength(str_: Dart_Handle, length: *mut isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the length of UTF-8 encoded representation for a string.\n\n \\param str A String.\n \\param length Returns the length of UTF-8 encoded representation for string.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_StringUTF8Length(str_: Dart_Handle, length: *mut isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a String built from the provided C string\n (There is an implicit assumption that the C string passed in contains\n  UTF-8 encoded characters and '\\0' is considered as a termination\n  character).\n\n \\param str A C String\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewStringFromCString(str_: *const ::core::ffi::c_char) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a String built from an array of UTF-8 encoded characters.\n\n \\param utf8_array An array of UTF-8 encoded characters.\n \\param length The length of the codepoints array.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewStringFromUTF8(utf8_array: *const u8, length: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a String built from an array of UTF-16 encoded characters.\n\n \\param utf16_array An array of UTF-16 encoded characters.\n \\param length The length of the codepoints array.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewStringFromUTF16(utf16_array: *const u16, length: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a String built from an array of UTF-32 encoded characters.\n\n \\param utf32_array An array of UTF-32 encoded characters.\n \\param length The length of the codepoints array.\n\n \\return The String object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewStringFromUTF32(utf32_array: *const i32, length: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the C string representation of a String.\n (It is a sequence of UTF-8 encoded values with a '\\0' termination.)\n\n \\param str A string.\n \\param cstr Returns the String represented as a C string.\n   This C string is scope allocated and is only valid until\n   the next call to Dart_ExitScope.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_StringToCString(str_: Dart_Handle, cstr: *mut *const ::core::ffi::c_char) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets a UTF-8 encoded representation of a String.\n\n Any unpaired surrogate code points in the string will be converted as\n replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8). If you need\n to preserve unpaired surrogates, use the Dart_StringToUTF16 function.\n\n \\param str A string.\n \\param utf8_array Returns the String represented as UTF-8 code\n   units.  This UTF-8 array is scope allocated and is only valid\n   until the next call to Dart_ExitScope.\n \\param length Used to return the length of the array which was\n   actually used.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_StringToUTF8(str_: Dart_Handle, utf8_array: *mut *mut u8, length: *mut isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Copies the UTF-8 encoded representation of a String into specified buffer.\n\n Any unpaired surrogate code points in the string will be converted as\n replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8).\n\n \\param str A string.\n \\param utf8_array Buffer into which the UTF-8 encoded representation of\n   the string is copied into.\n   The buffer is allocated and managed by the caller.\n \\param length Specifies the length of the buffer passed in.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_CopyUTF8EncodingOfString(str_: Dart_Handle, utf8_array: *mut u8, length: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the data corresponding to the string object. This function returns\n the data only for Latin-1 (ISO-8859-1) string objects. For all other\n string objects it returns an error.\n\n \\param str A string.\n \\param latin1_array An array allocated by the caller, used to return\n   the string data.\n \\param length Used to pass in the length of the provided array.\n   Used to return the length of the array which was actually used.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_StringToLatin1(str_: Dart_Handle, latin1_array: *mut u8, length: *mut isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the UTF-16 encoded representation of a string.\n\n \\param str A string.\n \\param utf16_array An array allocated by the caller, used to return\n   the array of UTF-16 encoded characters.\n \\param length Used to pass in the length of the provided array.\n   Used to return the length of the array which was actually used.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_StringToUTF16(str_: Dart_Handle, utf16_array: *mut u16, length: *mut isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the storage size in bytes of a String.\n\n \\param str A String.\n \\param size Returns the storage size in bytes of the String.\n  This is the size in bytes needed to store the String.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_StringStorageSize(str_: Dart_Handle, size: *mut isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Retrieves some properties associated with a String.\n Properties retrieved are:\n - character size of the string (one or two byte)\n - length of the string\n - peer pointer of string if it is an external string.\n \\param str A String.\n \\param char_size Returns the character size of the String.\n \\param str_len Returns the length of the String.\n \\param peer Returns the peer pointer associated with the String or 0 if\n   there is no peer pointer for it.\n \\return Success if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_StringGetProperties(
		str_: Dart_Handle, char_size: *mut isize, str_len: *mut isize, peer: *mut *mut ::core::ffi::c_void,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a List<dynamic> of the desired length.\n\n \\param length The length of the list.\n\n \\return The List object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewList(length: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a List of the desired length with the desired element type.\n\n \\param element_type Handle to a nullable type object. E.g., from\n Dart_GetType or Dart_GetNullableType.\n\n \\param length The length of the list.\n\n \\return The List object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewListOfType(element_type: Dart_Handle, length: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a List of the desired length with the desired element type, filled\n with the provided object.\n\n \\param element_type Handle to a type object. E.g., from Dart_GetType.\n\n \\param fill_object Handle to an object of type 'element_type' that will be\n used to populate the list. This parameter can only be Dart_Null() if the\n length of the list is 0 or 'element_type' is a nullable type.\n\n \\param length The length of the list.\n\n \\return The List object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewListOfTypeFilled(element_type: Dart_Handle, fill_object: Dart_Handle, length: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the length of a List.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param length Returns the length of the List.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_ListLength(list: Dart_Handle, length: *mut isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the Object at some index of a List.\n\n If the index is out of bounds, an error occurs.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param index A valid index into the List.\n\n \\return The Object in the List at the specified index if no error\n   occurs. Otherwise returns an error handle."]
	pub fn Dart_ListGetAt(list: Dart_Handle, index: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets a range of Objects from a List.\n\n If any of the requested index values are out of bounds, an error occurs.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param offset The offset of the first item to get.\n \\param length The number of items to get.\n \\param result A pointer to fill with the objects.\n\n \\return Success if no error occurs during the operation."]
	pub fn Dart_ListGetRange(list: Dart_Handle, offset: isize, length: isize, result: *mut Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Sets the Object at some index of a List.\n\n If the index is out of bounds, an error occurs.\n\n May generate an unhandled exception error.\n\n \\param list A List.\n \\param index A valid index into the List.\n \\param value The Object to put in the List.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_ListSetAt(list: Dart_Handle, index: isize, value: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " May generate an unhandled exception error."]
	pub fn Dart_ListGetAsBytes(list: Dart_Handle, offset: isize, native_array: *mut u8, length: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " May generate an unhandled exception error."]
	pub fn Dart_ListSetAsBytes(list: Dart_Handle, offset: isize, native_array: *const u8, length: isize)
	-> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the Object at some key of a Map.\n\n May generate an unhandled exception error.\n\n \\param map A Map.\n \\param key An Object.\n\n \\return The value in the map at the specified key, null if the map does not\n   contain the key, or an error handle."]
	pub fn Dart_MapGetAt(map: Dart_Handle, key: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns whether the Map contains a given key.\n\n May generate an unhandled exception error.\n\n \\param map A Map.\n\n \\return A handle on a boolean indicating whether map contains the key.\n   Otherwise returns an error handle."]
	pub fn Dart_MapContainsKey(map: Dart_Handle, key: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the list of keys of a Map.\n\n May generate an unhandled exception error.\n\n \\param map A Map.\n\n \\return The list of key Objects if no error occurs. Otherwise returns an\n   error handle."]
	pub fn Dart_MapKeys(map: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Return type if this object is a TypedData object.\n\n \\return kInvalid if the object is not a TypedData object or the appropriate\n   Dart_TypedData_Type."]
	pub fn Dart_GetTypeOfTypedData(object: Dart_Handle) -> Dart_TypedData_Type;
}
extern "C" {
	#[doc = " Return type if this object is an external TypedData object.\n\n \\return kInvalid if the object is not an external TypedData object or\n   the appropriate Dart_TypedData_Type."]
	pub fn Dart_GetTypeOfExternalTypedData(object: Dart_Handle) -> Dart_TypedData_Type;
}
extern "C" {
	#[doc = " Returns a TypedData object of the desired length and type.\n\n \\param type The type of the TypedData object.\n \\param length The length of the TypedData object (length in type units).\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewTypedData(type_: Dart_TypedData_Type, length: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a TypedData object which references an external data array.\n\n \\param type The type of the data array.\n \\param data A data array. This array must not move.\n \\param length The length of the data array (length in type units).\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewExternalTypedData(
		type_: Dart_TypedData_Type, data: *mut ::core::ffi::c_void, length: isize,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a TypedData object which references an external data array.\n\n \\param type The type of the data array.\n \\param data A data array. This array must not move.\n \\param length The length of the data array (length in type units).\n \\param peer A pointer to a native object or NULL.  This value is\n   provided to callback when it is invoked.\n \\param external_allocation_size The number of externally allocated\n   bytes for peer. Used to inform the garbage collector.\n \\param callback A function pointer that will be invoked sometime\n   after the object is garbage collected, unless the handle has been deleted.\n   A valid callback needs to be specified it cannot be NULL.\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewExternalTypedDataWithFinalizer(
		type_: Dart_TypedData_Type, data: *mut ::core::ffi::c_void, length: isize, peer: *mut ::core::ffi::c_void,
		external_allocation_size: isize, callback: Dart_HandleFinalizer,
	) -> Dart_Handle;
}
extern "C" {
	pub fn Dart_NewUnmodifiableExternalTypedDataWithFinalizer(
		type_: Dart_TypedData_Type, data: *const ::core::ffi::c_void, length: isize, peer: *mut ::core::ffi::c_void,
		external_allocation_size: isize, callback: Dart_HandleFinalizer,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a ByteBuffer object for the typed data.\n\n \\param typed_data The TypedData object.\n\n \\return The ByteBuffer object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_NewByteBuffer(typed_data: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Acquires access to the internal data address of a TypedData object.\n\n \\param object The typed data object whose internal data address is to\n    be accessed.\n \\param type The type of the object is returned here.\n \\param data The internal data address is returned here.\n \\param len Size of the typed array is returned here.\n\n Notes:\n   When the internal address of the object is acquired any calls to a\n   Dart API function that could potentially allocate an object or run\n   any Dart code will return an error.\n\n   Any Dart API functions for accessing the data should not be called\n   before the corresponding release. In particular, the object should\n   not be acquired again before its release. This leads to undefined\n   behavior.\n\n \\return Success if the internal data address is acquired successfully.\n   Otherwise, returns an error handle."]
	pub fn Dart_TypedDataAcquireData(
		object: Dart_Handle, type_: *mut Dart_TypedData_Type, data: *mut *mut ::core::ffi::c_void, len: *mut isize,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Releases access to the internal data address that was acquired earlier using\n Dart_TypedDataAcquireData.\n\n \\param object The typed data object whose internal data address is to be\n   released.\n\n \\return Success if the internal data address is released successfully.\n   Otherwise, returns an error handle."]
	pub fn Dart_TypedDataReleaseData(object: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns the TypedData object associated with the ByteBuffer object.\n\n \\param byte_buffer The ByteBuffer object.\n\n \\return The TypedData object if no error occurs. Otherwise returns\n   an error handle."]
	pub fn Dart_GetDataFromByteBuffer(byte_buffer: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Invokes a constructor, creating a new object.\n\n This function allows hidden constructors (constructors with leading\n underscores) to be called.\n\n \\param type Type of object to be constructed.\n \\param constructor_name The name of the constructor to invoke.  Use\n   Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.\n   This name should not include the name of the class.\n \\param number_of_arguments Size of the arguments array.\n \\param arguments An array of arguments to the constructor.\n\n \\return If the constructor is called and completes successfully,\n   then the new object. If an error occurs during execution, then an\n   error handle is returned."]
	pub fn Dart_New(
		type_: Dart_Handle, constructor_name: Dart_Handle, number_of_arguments: ::core::ffi::c_int,
		arguments: *mut Dart_Handle,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Allocate a new object without invoking a constructor.\n\n \\param type The type of an object to be allocated.\n\n \\return The new object. If an error occurs during execution, then an\n   error handle is returned."]
	pub fn Dart_Allocate(type_: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Allocate a new object without invoking a constructor, and sets specified\n  native fields.\n\n \\param type The type of an object to be allocated.\n \\param num_native_fields The number of native fields to set.\n \\param native_fields An array containing the value of native fields.\n\n \\return The new object. If an error occurs during execution, then an\n   error handle is returned."]
	pub fn Dart_AllocateWithNativeFields(
		type_: Dart_Handle, num_native_fields: isize, native_fields: *const isize,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Invokes a method or function.\n\n The 'target' parameter may be an object, type, or library.  If\n 'target' is an object, then this function will invoke an instance\n method.  If 'target' is a type, then this function will invoke a\n static method.  If 'target' is a library, then this function will\n invoke a top-level function from that library.\n NOTE: This API call cannot be used to invoke methods of a type object.\n\n This function ignores visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param target An object, type, or library.\n \\param name The name of the function or method to invoke.\n \\param number_of_arguments Size of the arguments array.\n \\param arguments An array of arguments to the function.\n\n \\return If the function or method is called and completes\n   successfully, then the return value is returned. If an error\n   occurs during execution, then an error handle is returned."]
	pub fn Dart_Invoke(
		target: Dart_Handle, name: Dart_Handle, number_of_arguments: ::core::ffi::c_int, arguments: *mut Dart_Handle,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Invokes a Closure with the given arguments.\n\n May generate an unhandled exception error.\n\n \\return If no error occurs during execution, then the result of\n   invoking the closure is returned. If an error occurs during\n   execution, then an error handle is returned."]
	pub fn Dart_InvokeClosure(
		closure: Dart_Handle, number_of_arguments: ::core::ffi::c_int, arguments: *mut Dart_Handle,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Invokes a Generative Constructor on an object that was previously\n allocated using Dart_Allocate/Dart_AllocateWithNativeFields.\n\n The 'object' parameter must be an object.\n\n This function ignores visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param object An object.\n \\param name The name of the constructor to invoke.\n   Use Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.\n \\param number_of_arguments Size of the arguments array.\n \\param arguments An array of arguments to the function.\n\n \\return If the constructor is called and completes\n   successfully, then the object is returned. If an error\n   occurs during execution, then an error handle is returned."]
	pub fn Dart_InvokeConstructor(
		object: Dart_Handle, name: Dart_Handle, number_of_arguments: ::core::ffi::c_int, arguments: *mut Dart_Handle,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the value of a field.\n\n The 'container' parameter may be an object, type, or library.  If\n 'container' is an object, then this function will access an\n instance field.  If 'container' is a type, then this function will\n access a static field.  If 'container' is a library, then this\n function will access a top-level variable.\n NOTE: This API call cannot be used to access fields of a type object.\n\n This function ignores field visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param container An object, type, or library.\n \\param name A field name.\n\n \\return If no error occurs, then the value of the field is\n   returned. Otherwise an error handle is returned."]
	pub fn Dart_GetField(container: Dart_Handle, name: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Sets the value of a field.\n\n The 'container' parameter may actually be an object, type, or\n library.  If 'container' is an object, then this function will\n access an instance field.  If 'container' is a type, then this\n function will access a static field.  If 'container' is a library,\n then this function will access a top-level variable.\n NOTE: This API call cannot be used to access fields of a type object.\n\n This function ignores field visibility (leading underscores in names).\n\n May generate an unhandled exception error.\n\n \\param container An object, type, or library.\n \\param name A field name.\n \\param value The new field value.\n\n \\return A valid handle if no error occurs."]
	pub fn Dart_SetField(container: Dart_Handle, name: Dart_Handle, value: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Throws an exception.\n\n This function causes a Dart language exception to be thrown. This\n will proceed in the standard way, walking up Dart frames until an\n appropriate 'catch' block is found, executing 'finally' blocks,\n etc.\n\n If an error handle is passed into this function, the error is\n propagated immediately.  See Dart_PropagateError for a discussion\n of error propagation.\n\n If successful, this function does not return. Note that this means\n that the destructors of any stack-allocated C++ objects will not be\n called. If there are no Dart frames on the stack, an error occurs.\n\n \\return An error handle if the exception was not thrown.\n   Otherwise the function does not return."]
	pub fn Dart_ThrowException(exception: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Rethrows an exception.\n\n Rethrows an exception, unwinding all dart frames on the stack. If\n successful, this function does not return. Note that this means\n that the destructors of any stack-allocated C++ objects will not be\n called. If there are no Dart frames on the stack, an error occurs.\n\n \\return An error handle if the exception was not thrown.\n   Otherwise the function does not return."]
	pub fn Dart_ReThrowException(exception: Dart_Handle, stacktrace: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the number of native instance fields in an object."]
	pub fn Dart_GetNativeInstanceFieldCount(obj: Dart_Handle, count: *mut ::core::ffi::c_int) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the value of a native field.\n\n TODO(turnidge): Document."]
	pub fn Dart_GetNativeInstanceField(obj: Dart_Handle, index: ::core::ffi::c_int, value: *mut isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Sets the value of a native field.\n\n TODO(turnidge): Document."]
	pub fn Dart_SetNativeInstanceField(obj: Dart_Handle, index: ::core::ffi::c_int, value: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Extracts current isolate group data from the native arguments structure."]
	pub fn Dart_GetNativeIsolateGroupData(args: Dart_NativeArguments) -> *mut ::core::ffi::c_void;
}
extern "C" {
	#[doc = " Gets the native arguments based on the types passed in and populates\n the passed arguments buffer with appropriate native values.\n\n \\param args the Native arguments block passed into the native call.\n \\param num_arguments length of argument descriptor array and argument\n   values array passed in.\n \\param arg_descriptors an array that describes the arguments that\n   need to be retrieved. For each argument to be retrieved the descriptor\n   contains the argument number (0, 1 etc.) and the argument type\n   described using Dart_NativeArgument_Type, e.g:\n   DART_NATIVE_ARG_DESCRIPTOR(Dart_NativeArgument_kBool, 1) indicates\n   that the first argument is to be retrieved and it should be a boolean.\n \\param arg_values array into which the native arguments need to be\n   extracted into, the array is allocated by the caller (it could be\n   stack allocated to avoid the malloc/free performance overhead).\n\n \\return Success if all the arguments could be extracted correctly,\n   returns an error handle if there were any errors while extracting the\n   arguments (mismatched number of arguments, incorrect types, etc.)."]
	pub fn Dart_GetNativeArguments(
		args: Dart_NativeArguments, num_arguments: ::core::ffi::c_int,
		arg_descriptors: *const Dart_NativeArgument_Descriptor, arg_values: *mut Dart_NativeArgument_Value,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the native argument at some index."]
	pub fn Dart_GetNativeArgument(args: Dart_NativeArguments, index: ::core::ffi::c_int) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the number of native arguments."]
	pub fn Dart_GetNativeArgumentCount(args: Dart_NativeArguments) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " Gets all the native fields of the native argument at some index.\n \\param args Native arguments structure.\n \\param arg_index Index of the desired argument in the structure above.\n \\param num_fields size of the intptr_t array 'field_values' passed in.\n \\param field_values intptr_t array in which native field values are returned.\n \\return Success if the native fields where copied in successfully. Otherwise\n   returns an error handle. On success the native field values are copied\n   into the 'field_values' array, if the argument at 'arg_index' is a\n   null object then 0 is copied as the native field values into the\n   'field_values' array."]
	pub fn Dart_GetNativeFieldsOfArgument(
		args: Dart_NativeArguments, arg_index: ::core::ffi::c_int, num_fields: ::core::ffi::c_int,
		field_values: *mut isize,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the native field of the receiver."]
	pub fn Dart_GetNativeReceiver(args: Dart_NativeArguments, value: *mut isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets a string native argument at some index.\n \\param args Native arguments structure.\n \\param arg_index Index of the desired argument in the structure above.\n \\param peer Returns the peer pointer if the string argument has one.\n \\return Success if the string argument has a peer, if it does not\n   have a peer then the String object is returned. Otherwise returns\n   an error handle (argument is not a String object)."]
	pub fn Dart_GetNativeStringArgument(
		args: Dart_NativeArguments, arg_index: ::core::ffi::c_int, peer: *mut *mut ::core::ffi::c_void,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets an integer native argument at some index.\n \\param args Native arguments structure.\n \\param index Index of the desired argument in the structure above.\n \\param value Returns the integer value if the argument is an Integer.\n \\return Success if no error occurs. Otherwise returns an error handle."]
	pub fn Dart_GetNativeIntegerArgument(
		args: Dart_NativeArguments, index: ::core::ffi::c_int, value: *mut i64,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets a boolean native argument at some index.\n \\param args Native arguments structure.\n \\param index Index of the desired argument in the structure above.\n \\param value Returns the boolean value if the argument is a Boolean.\n \\return Success if no error occurs. Otherwise returns an error handle."]
	pub fn Dart_GetNativeBooleanArgument(
		args: Dart_NativeArguments, index: ::core::ffi::c_int, value: *mut bool,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets a double native argument at some index.\n \\param args Native arguments structure.\n \\param index Index of the desired argument in the structure above.\n \\param value Returns the double value if the argument is a double.\n \\return Success if no error occurs. Otherwise returns an error handle."]
	pub fn Dart_GetNativeDoubleArgument(
		args: Dart_NativeArguments, index: ::core::ffi::c_int, value: *mut f64,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Sets the return value for a native function.\n\n If retval is an Error handle, then error will be propagated once\n the native functions exits. See Dart_PropagateError for a\n discussion of how different types of errors are propagated."]
	pub fn Dart_SetReturnValue(args: Dart_NativeArguments, retval: Dart_Handle);
}
extern "C" {
	pub fn Dart_SetWeakHandleReturnValue(args: Dart_NativeArguments, rval: Dart_WeakPersistentHandle);
}
extern "C" {
	pub fn Dart_SetBooleanReturnValue(args: Dart_NativeArguments, retval: bool);
}
extern "C" {
	pub fn Dart_SetIntegerReturnValue(args: Dart_NativeArguments, retval: i64);
}
extern "C" {
	pub fn Dart_SetDoubleReturnValue(args: Dart_NativeArguments, retval: f64);
}
extern "C" {
	#[doc = " Sets the environment callback for the current isolate. This\n callback is used to lookup environment values by name in the\n current environment. This enables the embedder to supply values for\n the const constructors bool.fromEnvironment, int.fromEnvironment\n and String.fromEnvironment."]
	pub fn Dart_SetEnvironmentCallback(callback: Dart_EnvironmentCallback) -> Dart_Handle;
}
extern "C" {
	#[doc = " Sets the callback used to resolve native functions for a library.\n\n \\param library A library.\n \\param resolver A native entry resolver.\n\n \\return A valid handle if the native resolver was set successfully."]
	pub fn Dart_SetNativeResolver(
		library: Dart_Handle, resolver: Dart_NativeEntryResolver, symbol: Dart_NativeEntrySymbol,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns the callback used to resolve native functions for a library.\n\n \\param library A library.\n \\param resolver a pointer to a Dart_NativeEntryResolver\n\n \\return A valid handle if the library was found."]
	pub fn Dart_GetNativeResolver(library: Dart_Handle, resolver: *mut Dart_NativeEntryResolver) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns the callback used to resolve native function symbols for a library.\n\n \\param library A library.\n \\param resolver a pointer to a Dart_NativeEntrySymbol.\n\n \\return A valid handle if the library was found."]
	pub fn Dart_GetNativeSymbol(library: Dart_Handle, resolver: *mut Dart_NativeEntrySymbol) -> Dart_Handle;
}
extern "C" {
	#[doc = " Sets the callback used to resolve FFI native functions for a library.\n The resolved functions are expected to be a C function pointer of the\n correct signature (as specified in the `@Native<NFT>()` function\n annotation in Dart code).\n\n NOTE: This is an experimental feature and might change in the future.\n\n \\param library A library.\n \\param resolver A native function resolver.\n\n \\return A valid handle if the native resolver was set successfully."]
	pub fn Dart_SetFfiNativeResolver(library: Dart_Handle, resolver: Dart_FfiNativeResolver) -> Dart_Handle;
}
extern "C" {
	#[doc = " Initializes native asset resolution for the current isolate group.\n\n The caller is responsible for ensuring this is called right after isolate\n group creation, and before running any dart code (or spawning isolates).\n\n @param native_assets_api The callbacks used by native assets resolution.\n                          The VM does not take ownership of the parameter,\n                          it can be freed immediately after the call."]
	pub fn Dart_InitializeNativeAssetsResolver(native_assets_api: *mut NativeAssetsApi);
}
extern "C" {
	#[doc = " Sets library tag handler for the current isolate. This handler is\n used to handle the various tags encountered while loading libraries\n or scripts in the isolate.\n\n \\param handler Handler code to be used for handling the various tags\n   encountered while loading libraries or scripts in the isolate.\n\n \\return If no error occurs, the handler is set for the isolate.\n   Otherwise an error handle is returned.\n\n TODO(turnidge): Document."]
	pub fn Dart_SetLibraryTagHandler(handler: Dart_LibraryTagHandler) -> Dart_Handle;
}
extern "C" {
	#[doc = " Sets the deferred load handler for the current isolate. This handler is\n used to handle loading deferred imports in an AppJIT or AppAOT program."]
	pub fn Dart_SetDeferredLoadHandler(handler: Dart_DeferredLoadHandler) -> Dart_Handle;
}
extern "C" {
	#[doc = " Notifies the VM that a deferred load completed successfully. This function\n will eventually cause the corresponding `prefix.loadLibrary()` futures to\n complete.\n\n Requires the current isolate to be the same current isolate during the\n invocation of the Dart_DeferredLoadHandler."]
	pub fn Dart_DeferredLoadComplete(
		loading_unit_id: isize, snapshot_data: *const u8, snapshot_instructions: *const u8,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Notifies the VM that a deferred load failed. This function\n will eventually cause the corresponding `prefix.loadLibrary()` futures to\n complete with an error.\n\n If `transient` is true, future invocations of `prefix.loadLibrary()` will\n trigger new load requests. If false, futures invocation will complete with\n the same error.\n\n Requires the current isolate to be the same current isolate during the\n invocation of the Dart_DeferredLoadHandler."]
	pub fn Dart_DeferredLoadCompleteError(
		loading_unit_id: isize, error_message: *const ::core::ffi::c_char, transient: bool,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Loads the root library for the current isolate.\n\n Requires there to be no current root library.\n\n \\param kernel_buffer A buffer which contains a kernel binary (see\n     pkg/kernel/binary.md). Must remain valid until isolate group shutdown.\n \\param kernel_size Length of the passed in buffer.\n\n \\return A handle to the root library, or an error."]
	pub fn Dart_LoadScriptFromKernel(kernel_buffer: *const u8, kernel_size: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = " Gets the library for the root script for the current isolate.\n\n If the root script has not yet been set for the current isolate,\n this function returns Dart_Null().  This function never returns an\n error handle.\n\n \\return Returns the root Library for the current isolate or Dart_Null()."]
	pub fn Dart_RootLibrary() -> Dart_Handle;
}
extern "C" {
	#[doc = " Sets the root library for the current isolate.\n\n \\return Returns an error handle if `library` is not a library handle."]
	pub fn Dart_SetRootLibrary(library: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Lookup or instantiate a legacy type by name and type arguments from a\n Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The class name for the type.\n \\param number_of_type_arguments Number of type arguments.\n   For non parametric types the number of type arguments would be 0.\n \\param type_arguments Pointer to an array of type arguments.\n   For non parametric types a NULL would be passed in for this argument.\n\n \\return If no error occurs, the type is returned.\n   Otherwise an error handle is returned."]
	pub fn Dart_GetType(
		library: Dart_Handle, class_name: Dart_Handle, number_of_type_arguments: isize,
		type_arguments: *mut Dart_Handle,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Lookup or instantiate a nullable type by name and type arguments from\n Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The class name for the type.\n \\param number_of_type_arguments Number of type arguments.\n   For non parametric types the number of type arguments would be 0.\n \\param type_arguments Pointer to an array of type arguments.\n   For non parametric types a NULL would be passed in for this argument.\n\n \\return If no error occurs, the type is returned.\n   Otherwise an error handle is returned."]
	pub fn Dart_GetNullableType(
		library: Dart_Handle, class_name: Dart_Handle, number_of_type_arguments: isize,
		type_arguments: *mut Dart_Handle,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Lookup or instantiate a non-nullable type by name and type arguments from\n Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The class name for the type.\n \\param number_of_type_arguments Number of type arguments.\n   For non parametric types the number of type arguments would be 0.\n \\param type_arguments Pointer to an array of type arguments.\n   For non parametric types a NULL would be passed in for this argument.\n\n \\return If no error occurs, the type is returned.\n   Otherwise an error handle is returned."]
	pub fn Dart_GetNonNullableType(
		library: Dart_Handle, class_name: Dart_Handle, number_of_type_arguments: isize,
		type_arguments: *mut Dart_Handle,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Creates a nullable version of the provided type.\n\n \\param type The type to be converted to a nullable type.\n\n \\return If no error occurs, a nullable type is returned.\n   Otherwise an error handle is returned."]
	pub fn Dart_TypeToNullableType(type_: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Creates a non-nullable version of the provided type.\n\n \\param type The type to be converted to a non-nullable type.\n\n \\return If no error occurs, a non-nullable type is returned.\n   Otherwise an error handle is returned."]
	pub fn Dart_TypeToNonNullableType(type_: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " A type's nullability.\n\n \\param type A Dart type.\n \\param result An out parameter containing the result of the check. True if\n the type is of the specified nullability, false otherwise.\n\n \\return Returns an error handle if type is not of type Type."]
	pub fn Dart_IsNullableType(type_: Dart_Handle, result: *mut bool) -> Dart_Handle;
}
extern "C" {
	pub fn Dart_IsNonNullableType(type_: Dart_Handle, result: *mut bool) -> Dart_Handle;
}
extern "C" {
	#[doc = " Lookup a class or interface by name from a Library.\n\n \\param library The library containing the class or interface.\n \\param class_name The name of the class or interface.\n\n \\return If no error occurs, the class or interface is\n   returned. Otherwise an error handle is returned."]
	pub fn Dart_GetClass(library: Dart_Handle, class_name: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns an import path to a Library, such as \"file:///test.dart\" or\n \"dart:core\"."]
	pub fn Dart_LibraryUrl(library: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns a URL from which a Library was loaded."]
	pub fn Dart_LibraryResolvedUrl(library: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " \\return An array of libraries."]
	pub fn Dart_GetLoadedLibraries() -> Dart_Handle;
}
extern "C" {
	pub fn Dart_LookupLibrary(url: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Report an loading error for the library.\n\n \\param library The library that failed to load.\n \\param error The Dart error instance containing the load error.\n\n \\return If the VM handles the error, the return value is\n a null handle. If it doesn't handle the error, the error\n object is returned."]
	pub fn Dart_LibraryHandleError(library: Dart_Handle, error: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Called by the embedder to load a partial program. Does not set the root\n library.\n\n \\param kernel_buffer A buffer which contains a kernel binary (see\n     pkg/kernel/binary.md). Must remain valid until isolate shutdown.\n \\param kernel_buffer_size Length of the passed in buffer.\n\n \\return A handle to the main library of the compilation unit, or an error."]
	pub fn Dart_LoadLibraryFromKernel(kernel_buffer: *const u8, kernel_buffer_size: isize) -> Dart_Handle;
}
extern "C" {
	pub fn Dart_LoadLibrary(kernel_buffer: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	#[doc = " Indicates that all outstanding load requests have been satisfied.\n This finalizes all the new classes loaded and optionally completes\n deferred library futures.\n\n Requires there to be a current isolate.\n\n \\param complete_futures Specify true if all deferred library\n  futures should be completed, false otherwise.\n\n \\return Success if all classes have been finalized and deferred library\n   futures are completed. Otherwise, returns an error."]
	pub fn Dart_FinalizeLoading(complete_futures: bool) -> Dart_Handle;
}
extern "C" {
	#[doc = " Returns the value of peer field of 'object' in 'peer'.\n\n \\param object An object.\n \\param peer An out parameter that returns the value of the peer\n   field.\n\n \\return Returns an error if 'object' is a subtype of Null, num, or\n   bool."]
	pub fn Dart_GetPeer(object: Dart_Handle, peer: *mut *mut ::core::ffi::c_void) -> Dart_Handle;
}
extern "C" {
	#[doc = " Sets the value of the peer field of 'object' to the value of\n 'peer'.\n\n \\param object An object.\n \\param peer A value to store in the peer field.\n\n \\return Returns an error if 'object' is a subtype of Null, num, or\n   bool."]
	pub fn Dart_SetPeer(object: Dart_Handle, peer: *mut ::core::ffi::c_void) -> Dart_Handle;
}
extern "C" {
	pub fn Dart_IsKernelIsolate(isolate: Dart_Isolate) -> bool;
}
extern "C" {
	pub fn Dart_KernelIsolateIsRunning() -> bool;
}
extern "C" {
	pub fn Dart_KernelPort() -> Dart_Port;
}
extern "C" {
	#[doc = " Compiles the given `script_uri` to a kernel file.\n\n \\param platform_kernel A buffer containing the kernel of the platform (e.g.\n `vm_platform_strong.dill`). The VM does not take ownership of this memory.\n\n \\param platform_kernel_size The length of the platform_kernel buffer.\n\n \\param snapshot_compile Set to `true` when the compilation is for a snapshot.\n This is used by the frontend to determine if compilation related information\n should be printed to console (e.g., null safety mode).\n\n \\param embed_sources Set to `true` when sources should be embedded in the\n kernel file.\n\n \\param verbosity Specifies the logging behavior of the kernel compilation\n service.\n\n \\return Returns the result of the compilation.\n\n On a successful compilation the returned [Dart_KernelCompilationResult] has\n a status of [Dart_KernelCompilationStatus_Ok] and the `kernel`/`kernel_size`\n fields are set. The caller takes ownership of the malloc()ed buffer.\n\n On a failed compilation the `error` might be set describing the reason for\n the failed compilation. The caller takes ownership of the malloc()ed\n error.\n\n Requires there to be a current isolate."]
	pub fn Dart_CompileToKernel(
		script_uri: *const ::core::ffi::c_char, platform_kernel: *const u8, platform_kernel_size: isize,
		incremental_compile: bool, snapshot_compile: bool, embed_sources: bool,
		package_config: *const ::core::ffi::c_char, verbosity: Dart_KernelCompilationVerbosityLevel,
	) -> Dart_KernelCompilationResult;
}
extern "C" {
	pub fn Dart_KernelListDependencies() -> Dart_KernelCompilationResult;
}
extern "C" {
	#[doc = " Sets the kernel buffer which will be used to load Dart SDK sources\n dynamically at runtime.\n\n \\param platform_kernel A buffer containing kernel which has sources for the\n Dart SDK populated. Note: The VM does not take ownership of this memory.\n\n \\param platform_kernel_size The length of the platform_kernel buffer."]
	pub fn Dart_SetDartLibrarySourcesKernel(platform_kernel: *const u8, platform_kernel_size: isize);
}
extern "C" {
	#[doc = " Always return true as the VM only supports strong null safety."]
	pub fn Dart_DetectNullSafety(
		script_uri: *const ::core::ffi::c_char, package_config: *const ::core::ffi::c_char,
		original_working_directory: *const ::core::ffi::c_char, snapshot_data: *const u8,
		snapshot_instructions: *const u8, kernel_buffer: *const u8, kernel_buffer_size: isize,
	) -> bool;
}
extern "C" {
	#[doc = " Returns true if isolate is the service isolate.\n\n \\param isolate An isolate\n\n \\return Returns true if 'isolate' is the service isolate."]
	pub fn Dart_IsServiceIsolate(isolate: Dart_Isolate) -> bool;
}
extern "C" {
	#[doc = " Writes the CPU profile to the timeline as a series of 'instant' events.\n\n Note that this is an expensive operation.\n\n \\param main_port The main port of the Isolate whose profile samples to write.\n \\param error An optional error, must be free()ed by caller.\n\n \\return Returns true if the profile is successfully written and false\n         otherwise."]
	pub fn Dart_WriteProfileToTimeline(main_port: Dart_Port, error: *mut *mut ::core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Compiles all functions reachable from entry points and marks\n the isolate to disallow future compilation.\n\n Entry points should be specified using `@pragma(\"vm:entry-point\")`\n annotation.\n\n \\return An error handle if a compilation error or runtime error running const\n constructors was encountered."]
	pub fn Dart_Precompile() -> Dart_Handle;
}
extern "C" {
	pub fn Dart_LoadingUnitLibraryUris(loading_unit_id: isize) -> Dart_Handle;
}
extern "C" {
	#[doc = "  Creates a precompiled snapshot.\n   - A root library must have been loaded.\n   - Dart_Precompile must have been called.\n\n  Outputs an assembly file defining the symbols listed in the definitions\n  above.\n\n  The assembly should be compiled as a static or shared library and linked or\n  loaded by the embedder. Running this snapshot requires a VM compiled with\n  DART_PRECOMPILED_SNAPSHOT. The kDartVmSnapshotData and\n  kDartVmSnapshotInstructions should be passed to Dart_Initialize. The\n  kDartIsolateSnapshotData and kDartIsolateSnapshotInstructions should be\n  passed to Dart_CreateIsolateGroup.\n\n  The callback will be invoked one or more times to provide the assembly code.\n\n  If stripped is true, then the assembly code will not include DWARF\n  debugging sections.\n\n  If debug_callback_data is provided, debug_callback_data will be used with\n  the callback to provide separate debugging information.\n\n  \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_CreateAppAOTSnapshotAsAssembly(
		callback: Dart_StreamingWriteCallback, callback_data: *mut ::core::ffi::c_void, stripped: bool,
		debug_callback_data: *mut ::core::ffi::c_void,
	) -> Dart_Handle;
}
extern "C" {
	pub fn Dart_CreateAppAOTSnapshotAsAssemblies(
		next_callback: Dart_CreateLoadingUnitCallback, next_callback_data: *mut ::core::ffi::c_void, stripped: bool,
		write_callback: Dart_StreamingWriteCallback, close_callback: Dart_StreamingCloseCallback,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = "  Creates a precompiled snapshot.\n   - A root library must have been loaded.\n   - Dart_Precompile must have been called.\n\n  Outputs an ELF shared library defining the symbols\n   - _kDartVmSnapshotData\n   - _kDartVmSnapshotInstructions\n   - _kDartIsolateSnapshotData\n   - _kDartIsolateSnapshotInstructions\n\n  The shared library should be dynamically loaded by the embedder.\n  Running this snapshot requires a VM compiled with DART_PRECOMPILED_SNAPSHOT.\n  The kDartVmSnapshotData and kDartVmSnapshotInstructions should be passed to\n  Dart_Initialize. The kDartIsolateSnapshotData and\n  kDartIsolateSnapshotInstructions should be passed to Dart_CreateIsolate.\n\n  The callback will be invoked one or more times to provide the binary output.\n\n  If stripped is true, then the binary output will not include DWARF\n  debugging sections.\n\n  If debug_callback_data is provided, debug_callback_data will be used with\n  the callback to provide separate debugging information.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_CreateAppAOTSnapshotAsElf(
		callback: Dart_StreamingWriteCallback, callback_data: *mut ::core::ffi::c_void, stripped: bool,
		debug_callback_data: *mut ::core::ffi::c_void,
	) -> Dart_Handle;
}
extern "C" {
	pub fn Dart_CreateAppAOTSnapshotAsElfs(
		next_callback: Dart_CreateLoadingUnitCallback, next_callback_data: *mut ::core::ffi::c_void, stripped: bool,
		write_callback: Dart_StreamingWriteCallback, close_callback: Dart_StreamingCloseCallback,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = "  Like Dart_CreateAppAOTSnapshotAsAssembly, but only includes\n  kDartVmSnapshotData and kDartVmSnapshotInstructions. It also does\n  not strip DWARF information from the generated assembly or allow for\n  separate debug information."]
	pub fn Dart_CreateVMAOTSnapshotAsAssembly(
		callback: Dart_StreamingWriteCallback, callback_data: *mut ::core::ffi::c_void,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Sorts the class-ids in depth first traversal order of the inheritance\n tree. This is a costly operation, but it can make method dispatch\n more efficient and is done before writing snapshots.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_SortClasses() -> Dart_Handle;
}
extern "C" {
	#[doc = "  Creates a snapshot that caches compiled code and type feedback for faster\n  startup and quicker warmup in a subsequent process.\n\n  Outputs a snapshot in two pieces. The pieces should be passed to\n  Dart_CreateIsolateGroup in a VM using the same VM snapshot pieces used in the\n  current VM. The instructions piece must be loaded with read and execute\n  permissions; the data piece may be loaded as read-only.\n\n   - Requires the VM to have not been started with --precompilation.\n   - Not supported when targeting IA32.\n   - The VM writing the snapshot and the VM reading the snapshot must be the\n     same version, must be built in the same DEBUG/RELEASE/PRODUCT mode, must\n     be targeting the same architecture, and must both be in checked mode or\n     both in unchecked mode.\n\n  The buffers are scope allocated and are only valid until the next call to\n  Dart_ExitScope.\n\n \\return A valid handle if no error occurs during the operation."]
	pub fn Dart_CreateAppJITSnapshotAsBlobs(
		isolate_snapshot_data_buffer: *mut *mut u8, isolate_snapshot_data_size: *mut isize,
		isolate_snapshot_instructions_buffer: *mut *mut u8, isolate_snapshot_instructions_size: *mut isize,
	) -> Dart_Handle;
}
extern "C" {
	#[doc = " Get obfuscation map for precompiled code.\n\n Obfuscation map is encoded as a JSON array of pairs (original name,\n obfuscated name).\n\n \\return Returns an error handler if the VM was built in a mode that does not\n support obfuscation."]
	pub fn Dart_GetObfuscationMap(buffer: *mut *mut u8, buffer_length: *mut isize) -> Dart_Handle;
}
extern "C" {
	#[doc = "  Returns whether the VM only supports running from precompiled snapshots and\n  not from any other kind of snapshot or from source (that is, the VM was\n  compiled with DART_PRECOMPILED_RUNTIME)."]
	pub fn Dart_IsPrecompiledRuntime() -> bool;
}
extern "C" {
	#[doc = "  Print a native stack trace. Used for crash handling.\n\n  If context is NULL, prints the current stack trace. Otherwise, context\n  should be a CONTEXT* (Windows) or ucontext_t* (POSIX) from a signal handler\n  running on the current thread."]
	pub fn Dart_DumpNativeStackTrace(context: *mut ::core::ffi::c_void);
}
extern "C" {
	#[doc = "  Indicate that the process is about to abort, and the Dart VM should not\n  attempt to cleanup resources."]
	pub fn Dart_PrepareToAbort();
}
extern "C" {
	#[doc = "  Configure DWARF stack trace footnote callback."]
	pub fn Dart_SetDwarfStackTraceFootnoteCallback(callback: Dart_DwarfStackTraceFootnoteCallback);
}
extern "C" {
	#[doc = " Posts a message on some port. The message will contain the Dart_CObject\n object graph rooted in 'message'.\n\n While the message is being sent the state of the graph of Dart_CObject\n structures rooted in 'message' should not be accessed, as the message\n generation will make temporary modifications to the data. When the message\n has been sent the graph will be fully restored.\n\n If true is returned, the message was enqueued, and finalizers for external\n typed data will eventually run, even if the receiving isolate shuts down\n before processing the message. If false is returned, the message was not\n enqueued and ownership of external typed data in the message remains with the\n caller.\n\n This function may be called on any thread when the VM is running (that is,\n after Dart_Initialize has returned and before Dart_Cleanup has been called).\n\n \\param port_id The destination port.\n \\param message The message to send.\n\n \\return True if the message was posted."]
	pub fn Dart_PostCObject(port_id: Dart_Port, message: *mut Dart_CObject) -> bool;
}
extern "C" {
	#[doc = " Posts a message on some port. The message will contain the integer 'message'.\n\n \\param port_id The destination port.\n \\param message The message to send.\n\n \\return True if the message was posted."]
	pub fn Dart_PostInteger(port_id: Dart_Port, message: i64) -> bool;
}
extern "C" {
	#[doc = " Creates a new native port.  When messages are received on this\n native port, then they will be dispatched to the provided native\n message handler.\n\n \\param name The name of this port in debugging messages.\n \\param handler The C handler to run when messages arrive on the port.\n \\param handle_concurrently Is it okay to process requests on this\n                            native port concurrently?\n\n \\return If successful, returns the port id for the native port.  In\n   case of error, returns ILLEGAL_PORT."]
	pub fn Dart_NewNativePort(
		name: *const ::core::ffi::c_char, handler: Dart_NativeMessageHandler, handle_concurrently: bool,
	) -> Dart_Port;
}
extern "C" {
	#[doc = " Creates a new native port.  When messages are received on this\n native port, then they will be dispatched to the provided native\n message handler using up to |max_concurrency| concurrent threads.\n\n \\param name The name of this port in debugging messages.\n \\param handler The C handler to run when messages arrive on the port.\n \\param max_concurrency Size of the thread pool used by the native port.\n\n \\return If successful, returns the port id for the native port.  In\n   case of error, returns ILLEGAL_PORT."]
	pub fn Dart_NewConcurrentNativePort(
		name: *const ::core::ffi::c_char, handler: Dart_NativeMessageHandler, max_concurrency: isize,
	) -> Dart_Port;
}
extern "C" {
	#[doc = " Closes the native port with the given id.\n\n The port must have been allocated by a call to Dart_NewNativePort.\n\n \\param native_port_id The id of the native port to close.\n\n \\return Returns true if the port was closed successfully."]
	pub fn Dart_CloseNativePort(native_port_id: Dart_Port) -> bool;
}
extern "C" {
	#[doc = " Forces all loaded classes and functions to be compiled eagerly in\n the current isolate..\n\n TODO(turnidge): Document."]
	pub fn Dart_CompileAll() -> Dart_Handle;
}
extern "C" {
	#[doc = " Finalizes all classes."]
	pub fn Dart_FinalizeAllClasses() -> Dart_Handle;
}
extern "C" {
	pub fn Dart_ExecuteInternalCommand(
		command: *const ::core::ffi::c_char, arg: *mut ::core::ffi::c_void,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	#[doc = " \\mainpage Dynamically Linked Dart API\n\n This exposes a subset of symbols from dart_api.h and dart_native_api.h\n available in every Dart embedder through dynamic linking.\n\n All symbols are postfixed with _DL to indicate that they are dynamically\n linked and to prevent conflicts with the original symbol.\n\n Link `dart_api_dl.c` file into your library and invoke\n `Dart_InitializeApiDL` with `NativeApi.initializeApiDLData`.\n\n Returns 0 on success."]
	pub fn Dart_InitializeApiDL(data: *mut ::core::ffi::c_void) -> isize;
}
extern "C" {
	pub static mut Dart_PostCObject_DL: Dart_PostCObject_Type;
}
extern "C" {
	pub static mut Dart_PostInteger_DL: Dart_PostInteger_Type;
}
extern "C" {
	pub static mut Dart_NewNativePort_DL: Dart_NewNativePort_Type;
}
extern "C" {
	pub static mut Dart_CloseNativePort_DL: Dart_CloseNativePort_Type;
}
extern "C" {
	pub static mut Dart_IsError_DL: Dart_IsError_Type;
}
extern "C" {
	pub static mut Dart_IsApiError_DL: Dart_IsApiError_Type;
}
extern "C" {
	pub static mut Dart_IsUnhandledExceptionError_DL: Dart_IsUnhandledExceptionError_Type;
}
extern "C" {
	pub static mut Dart_IsCompilationError_DL: Dart_IsCompilationError_Type;
}
extern "C" {
	pub static mut Dart_IsFatalError_DL: Dart_IsFatalError_Type;
}
extern "C" {
	pub static mut Dart_GetError_DL: Dart_GetError_Type;
}
extern "C" {
	pub static mut Dart_ErrorHasException_DL: Dart_ErrorHasException_Type;
}
extern "C" {
	pub static mut Dart_ErrorGetException_DL: Dart_ErrorGetException_Type;
}
extern "C" {
	pub static mut Dart_ErrorGetStackTrace_DL: Dart_ErrorGetStackTrace_Type;
}
extern "C" {
	pub static mut Dart_NewApiError_DL: Dart_NewApiError_Type;
}
extern "C" {
	pub static mut Dart_NewCompilationError_DL: Dart_NewCompilationError_Type;
}
extern "C" {
	pub static mut Dart_NewUnhandledExceptionError_DL: Dart_NewUnhandledExceptionError_Type;
}
extern "C" {
	pub static mut Dart_PropagateError_DL: Dart_PropagateError_Type;
}
extern "C" {
	pub static mut Dart_HandleFromPersistent_DL: Dart_HandleFromPersistent_Type;
}
extern "C" {
	pub static mut Dart_HandleFromWeakPersistent_DL: Dart_HandleFromWeakPersistent_Type;
}
extern "C" {
	pub static mut Dart_NewPersistentHandle_DL: Dart_NewPersistentHandle_Type;
}
extern "C" {
	pub static mut Dart_SetPersistentHandle_DL: Dart_SetPersistentHandle_Type;
}
extern "C" {
	pub static mut Dart_DeletePersistentHandle_DL: Dart_DeletePersistentHandle_Type;
}
extern "C" {
	pub static mut Dart_NewWeakPersistentHandle_DL: Dart_NewWeakPersistentHandle_Type;
}
extern "C" {
	pub static mut Dart_DeleteWeakPersistentHandle_DL: Dart_DeleteWeakPersistentHandle_Type;
}
extern "C" {
	pub static mut Dart_NewFinalizableHandle_DL: Dart_NewFinalizableHandle_Type;
}
extern "C" {
	pub static mut Dart_DeleteFinalizableHandle_DL: Dart_DeleteFinalizableHandle_Type;
}
extern "C" {
	pub static mut Dart_CurrentIsolate_DL: Dart_CurrentIsolate_Type;
}
extern "C" {
	pub static mut Dart_ExitIsolate_DL: Dart_ExitIsolate_Type;
}
extern "C" {
	pub static mut Dart_EnterIsolate_DL: Dart_EnterIsolate_Type;
}
extern "C" {
	pub static mut Dart_Post_DL: Dart_Post_Type;
}
extern "C" {
	pub static mut Dart_NewSendPort_DL: Dart_NewSendPort_Type;
}
extern "C" {
	pub static mut Dart_NewSendPortEx_DL: Dart_NewSendPortEx_Type;
}
extern "C" {
	pub static mut Dart_SendPortGetId_DL: Dart_SendPortGetId_Type;
}
extern "C" {
	pub static mut Dart_SendPortGetIdEx_DL: Dart_SendPortGetIdEx_Type;
}
extern "C" {
	pub static mut Dart_EnterScope_DL: Dart_EnterScope_Type;
}
extern "C" {
	pub static mut Dart_ExitScope_DL: Dart_ExitScope_Type;
}
extern "C" {
	pub static mut Dart_IsNull_DL: Dart_IsNull_Type;
}
extern "C" {
	pub static mut Dart_Null_DL: Dart_Null_Type;
}
extern "C" {
	pub static mut Dart_UpdateExternalSize_DL: Dart_UpdateExternalSize_Type;
}
extern "C" {
	pub static mut Dart_UpdateFinalizableExternalSize_DL: Dart_UpdateFinalizableExternalSize_Type;
}
extern "C" {
	#[doc = " Register a Dart_ServiceRequestCallback to be called to handle\n requests for the named rpc on a specific isolate. The callback will\n be invoked with the current isolate set to the request target.\n\n \\param method The name of the method that this callback is responsible for.\n \\param callback The callback to invoke.\n \\param user_data The user data passed to the callback.\n\n NOTE: If multiple callbacks with the same name are registered, only\n the last callback registered will be remembered."]
	pub fn Dart_RegisterIsolateServiceRequestCallback(
		method: *const ::core::ffi::c_char, callback: Dart_ServiceRequestCallback, user_data: *mut ::core::ffi::c_void,
	);
}
extern "C" {
	#[doc = " Register a Dart_ServiceRequestCallback to be called to handle\n requests for the named rpc. The callback will be invoked without a\n current isolate.\n\n \\param method The name of the command that this callback is responsible for.\n \\param callback The callback to invoke.\n \\param user_data The user data passed to the callback.\n\n NOTE: If multiple callbacks with the same name are registered, only\n the last callback registered will be remembered."]
	pub fn Dart_RegisterRootServiceRequestCallback(
		method: *const ::core::ffi::c_char, callback: Dart_ServiceRequestCallback, user_data: *mut ::core::ffi::c_void,
	);
}
extern "C" {
	#[doc = " Register a Dart_ServiceRequestCallback to be called to handle\n requests for the named rpc. The callback will be invoked without a\n current isolate.\n\n \\param method The name of the command that this callback is responsible for.\n \\param callback The callback to invoke.\n \\param user_data The user data passed to the callback.\n\n NOTE: If multiple callbacks are registered, only the last callback registered\n will be remembered."]
	pub fn Dart_SetEmbedderInformationCallback(callback: Dart_EmbedderInformationCallback);
}
extern "C" {
	#[doc = " Invoke a vm-service method and wait for its result.\n\n \\param request_json The utf8-encoded json-rpc request.\n \\param request_json_length The length of the json-rpc request.\n\n \\param response_json The returned utf8-encoded json response, must be\n   free()ed by caller.\n \\param response_json_length The length of the returned json response.\n \\param error An optional error, must be free()ed by caller.\n\n \\return Whether the call was successfully performed.\n\n NOTE: This method does not need a current isolate and must not have the\n vm-isolate being the current isolate. It must be called after\n Dart_Initialize() and before Dart_Cleanup()."]
	pub fn Dart_InvokeVMServiceMethod(
		request_json: *mut u8, request_json_length: isize, response_json: *mut *mut u8,
		response_json_length: *mut isize, error: *mut *mut ::core::ffi::c_char,
	) -> bool;
}
extern "C" {
	#[doc = " Adds VM service stream callbacks.\n\n \\param listen_callback A function pointer to a listen callback function.\n   A listen callback function should not be already set when this function\n   is called. A NULL value removes the existing listen callback function\n   if any.\n\n \\param cancel_callback A function pointer to a cancel callback function.\n   A cancel callback function should not be already set when this function\n   is called. A NULL value removes the existing cancel callback function\n   if any.\n\n \\return Success if the callbacks were added.  Otherwise, returns an\n   error handle."]
	pub fn Dart_SetServiceStreamCallbacks(
		listen_callback: Dart_ServiceStreamListenCallback, cancel_callback: Dart_ServiceStreamCancelCallback,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Sends a data event to clients of the VM Service.\n\n A data event is used to pass an array of bytes to subscribed VM\n Service clients.  For example, in the standalone embedder, this is\n function used to provide WriteEvents on the Stdout and Stderr\n streams.\n\n If the embedder passes in a stream id for which no client is\n subscribed, then the event is ignored.\n\n \\param stream_id The id of the stream on which to post the event.\n\n \\param event_kind A string identifying what kind of event this is.\n   For example, 'WriteEvent'.\n\n \\param bytes A pointer to an array of bytes.\n\n \\param bytes_length The length of the byte array.\n\n \\return NULL if the arguments are well formed.  Otherwise, returns an\n   error string. The caller is responsible for freeing the error message."]
	pub fn Dart_ServiceSendDataEvent(
		stream_id: *const ::core::ffi::c_char, event_kind: *const ::core::ffi::c_char, bytes: *const u8,
		bytes_length: isize,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn Dart_SetFileModifiedCallback(file_modified_callback: Dart_FileModifiedCallback) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Returns true if isolate is currently reloading."]
	pub fn Dart_IsReloading() -> bool;
}
extern "C" {
	#[doc = " Enable tracking of specified timeline category. This is operational\n only when systrace timeline functionality is turned on.\n\n \\param categories A comma separated list of categories that need to\n   be enabled, the categories are\n   \"all\" : All categories\n   \"API\" - Execution of Dart C API functions\n   \"Compiler\" - Execution of Dart JIT compiler\n   \"CompilerVerbose\" - More detailed Execution of Dart JIT compiler\n   \"Dart\" - Execution of Dart code\n   \"Debugger\" - Execution of Dart debugger\n   \"Embedder\" - Execution of Dart embedder code\n   \"GC\" - Execution of Dart Garbage Collector\n   \"Isolate\" - Dart Isolate lifecycle execution\n   \"VM\" - Execution in Dart VM runtime code\n   \"\" - None\n\n  When \"all\" is specified all the categories are enabled.\n  When a comma separated list of categories is specified, the categories\n   that are specified will be enabled and the rest will be disabled.\n  When \"\" is specified all the categories are disabled.\n  The category names are case sensitive.\n  eg:  Dart_EnableTimelineCategory(\"all\");\n       Dart_EnableTimelineCategory(\"GC,API,Isolate\");\n       Dart_EnableTimelineCategory(\"GC,Debugger,Dart\");\n\n \\return True if the categories were successfully enabled, False otherwise."]
	pub fn Dart_SetEnabledTimelineCategory(categories: *const ::core::ffi::c_char) -> bool;
}
extern "C" {
	#[doc = " Returns a timestamp in microseconds. This timestamp is suitable for\n passing into the timeline system, and uses the same monotonic clock\n as dart:developer's Timeline.now.\n\n \\return A timestamp that can be passed to the timeline system."]
	pub fn Dart_TimelineGetMicros() -> i64;
}
extern "C" {
	#[doc = " Returns a raw timestamp in from the monotonic clock.\n\n \\return A raw timestamp from the monotonic clock."]
	pub fn Dart_TimelineGetTicks() -> i64;
}
extern "C" {
	#[doc = " Returns the frequency of the monotonic clock.\n\n \\return The frequency of the monotonic clock."]
	pub fn Dart_TimelineGetTicksFrequency() -> i64;
}
extern "C" {
	#[doc = " Add a timeline event to the embedder stream.\n\n Note regarding flow events: events must be associated with flow IDs in two\n different ways to allow flow events to be serialized correctly in both\n Chrome's JSON trace event format and Perfetto's proto trace format. Events\n of type |Dart_Timeline_Event_Flow_Begin|, |Dart_Timeline_Event_Flow_Step|,\n and |Dart_Timeline_Event_Flow_End| must be reported to support serialization\n in Chrome's trace format. The |flow_ids| argument must be supplied when\n reporting events of type |Dart_Timeline_Event_Begin|,\n |Dart_Timeline_Event_Duration|, |Dart_Timeline_Event_Instant|,\n |Dart_Timeline_Event_Async_Begin|, and |Dart_Timeline_Event_Async_Instant| to\n support serialization in Perfetto's proto format.\n\n The Dart VM can use various underlying recorders depending on configuration\n and operating system. Many recorders do not support all event types;\n unsupported event types are siliently dropped. Some recorders do not accept\n timestamps as input, instead implicitly using the time the event is recorded.\n For maximum compatibility, record events with the Begin and End types as they\n occur instead of using the Duration type or buffering.\n\n \\param label The name of the event. Its lifetime must extend at least until\n     Dart_Cleanup.\n \\param timestamp0 The first timestamp of the event.\n \\param timestamp1_or_id When reporting an event of type\n     |Dart_Timeline_Event_Duration|, the second (end) timestamp of the event\n     should be passed through |timestamp1_or_id|. When reporting an event of\n     type |Dart_Timeline_Event_Async_Begin|, |Dart_Timeline_Event_Async_End|,\n     or |Dart_Timeline_Event_Async_Instant|, the async ID associated with the\n     event should be passed through |timestamp1_or_id|. When reporting an\n     event of type |Dart_Timeline_Event_Flow_Begin|,\n     |Dart_Timeline_Event_Flow_Step|, or |Dart_Timeline_Event_Flow_End|, the\n     flow ID associated with the event should be passed through\n     |timestamp1_or_id|. When reporting an event of type\n     |Dart_Timeline_Event_Begin| or |Dart_Timeline_Event_End|, the event ID\n     associated with the event should be passed through |timestamp1_or_id|.\n     Note that this event ID will only be used by the MacOS recorder. The\n     argument to |timestamp1_or_id| will not be used when reporting events of\n     other types.\n \\param flow_id_count The number of flow IDs associated with this event.\n \\param flow_ids An array of flow IDs associated with this event. The array\n     may be reclaimed when this call returns.\n \\param argument_count The number of argument names and values.\n \\param argument_names An array of names of the arguments. The lifetime of the\n     names must extend at least until Dart_Cleanup. The array may be reclaimed\n     when this call returns.\n \\param argument_values An array of values of the arguments. The values and\n     the array may be reclaimed when this call returns."]
	pub fn Dart_RecordTimelineEvent(
		label: *const ::core::ffi::c_char, timestamp0: i64, timestamp1_or_id: i64, flow_id_count: isize,
		flow_ids: *const i64, type_: Dart_Timeline_Event_Type, argument_count: isize,
		argument_names: *mut *const ::core::ffi::c_char, argument_values: *mut *const ::core::ffi::c_char,
	);
}
extern "C" {
	#[doc = " Associates a name with the current thread. This name will be used to name\n threads in the timeline. Can only be called after a call to Dart_Initialize.\n\n \\param name The name of the thread."]
	pub fn Dart_SetThreadName(name: *const ::core::ffi::c_char);
}
extern "C" {
	#[doc = " Register a `Dart_TimelineRecorderCallback` to be called as timeline events\n are completed.\n\n The callback will be invoked without a current isolate.\n\n The callback will be invoked on the thread completing the event. Because\n `Dart_RecordTimelineEvent` may be called by any thread, the callback may be\n called on any thread.\n\n The callback may be invoked at any time after `Dart_Initialize` is called and\n before `Dart_Cleanup` returns.\n\n If multiple callbacks are registered, only the last callback registered\n will be remembered. Providing a NULL callback will clear the registration\n (i.e., a NULL callback produced a no-op instead of a crash).\n\n Setting a callback is insufficient to receive events through the callback. The\n VM flag `timeline_recorder` must also be set to `callback`."]
	pub fn Dart_SetTimelineRecorderCallback(callback: Dart_TimelineRecorderCallback);
}
extern "C" {
	#[doc = " Return metrics gathered for the VM and individual isolates."]
	pub fn Dart_IsolateGroupHeapOldUsedMetric(group: Dart_IsolateGroup) -> i64;
}
extern "C" {
	pub fn Dart_IsolateGroupHeapOldCapacityMetric(group: Dart_IsolateGroup) -> i64;
}
extern "C" {
	pub fn Dart_IsolateGroupHeapOldExternalMetric(group: Dart_IsolateGroup) -> i64;
}
extern "C" {
	pub fn Dart_IsolateGroupHeapNewUsedMetric(group: Dart_IsolateGroup) -> i64;
}
extern "C" {
	pub fn Dart_IsolateGroupHeapNewCapacityMetric(group: Dart_IsolateGroup) -> i64;
}
extern "C" {
	pub fn Dart_IsolateGroupHeapNewExternalMetric(group: Dart_IsolateGroup) -> i64;
}
extern "C" {
	pub fn Dart_GetCurrentUserTag() -> Dart_Handle;
}
extern "C" {
	pub fn Dart_GetDefaultUserTag() -> Dart_Handle;
}
extern "C" {
	pub fn Dart_NewUserTag(label: *const ::core::ffi::c_char) -> Dart_Handle;
}
extern "C" {
	pub fn Dart_SetCurrentUserTag(user_tag: Dart_Handle) -> Dart_Handle;
}
extern "C" {
	pub fn Dart_GetUserTagLabel(user_tag: Dart_Handle) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " Generate heap snapshot of the current isolate group and stream it into the\n given `callback`. VM would produce snapshot in chunks and send these chunks\n one by one back to the embedder by invoking the provided `callback`.\n\n This API enables embedder to stream snapshot into a file or socket without\n allocating a buffer to hold the whole snapshot in memory.\n\n The isolate group will be paused for the duration of this operation.\n\n \\param write Callback used to write chunks of the heap snapshot.\n\n \\param context Opaque context which would be passed on each invocation of\n   `write` callback.\n\n \\returns `nullptr` if the operation is successful otherwise error message.\n   Caller owns error message string and needs to `free` it."]
	pub fn Dart_WriteHeapSnapshot(
		write: Dart_HeapSnapshotWriteChunkCallback, context: *mut ::core::ffi::c_void,
	) -> *mut ::core::ffi::c_char;
}
