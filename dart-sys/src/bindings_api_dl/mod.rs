/* automatically generated by rust-bindgen 0.63.0 */

pub const DART_API_DL_MAJOR_VERSION: u32 = 2;
pub const DART_API_DL_MINOR_VERSION: u32 = 1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_Handle {
	_unused: [u8; 0],
}
/// An object reference managed by the Dart VM garbage collector.
///
/// Because the garbage collector may move objects, it is unsafe to
/// refer to objects directly. Instead, we refer to objects through
/// handles, which are known to the garbage collector and updated
/// automatically when the object is moved. Handles should be passed
/// by value (except in cases like out-parameters) and should never be
/// allocated on the heap.
///
/// Most functions in the Dart Embedding API return a handle. When a
/// function completes normally, this will be a valid handle to an
/// object in the Dart VM heap. This handle may represent the result of
/// the operation or it may be a special valid handle used merely to
/// indicate successful completion. Note that a valid handle may in
/// some cases refer to the null object.
///
/// --- Error handles ---
///
/// When a function encounters a problem that prevents it from
/// completing normally, it returns an error handle (See Dart_IsError).
/// An error handle has an associated error message that gives more
/// details about the problem (See Dart_GetError).
///
/// There are four kinds of error handles that can be produced,
/// depending on what goes wrong:
///
/// - Api error handles are produced when an api function is misused. This happens when a Dart
///   embedding api function is called with invalid arguments or in an invalid context.
///
/// - Unhandled exception error handles are produced when, during the execution of Dart code, an
///   exception is thrown but not caught. Prototypically this would occur during a call to
///   Dart_Invoke, but it can occur in any function which triggers the execution of Dart code (for
///   example, Dart_ToString).
///
///   An unhandled exception error provides access to an exception and
///   stacktrace via the functions Dart_ErrorGetException and
///   Dart_ErrorGetStackTrace.
///
/// - Compilation error handles are produced when, during the execution of Dart code, a compile-time
///   error occurs.  As above, this can occur in any function which triggers the execution of Dart
///   code.
///
/// - Fatal error handles are produced when the system wants to shut down the current isolate.
///
/// --- Propagating errors ---
///
/// When an error handle is returned from the top level invocation of
/// Dart code in a program, the embedder must handle the error as they
/// see fit.  Often, the embedder will print the error message produced
/// by Dart_Error and exit the program.
///
/// When an error is returned while in the body of a native function,
/// it can be propagated up the call stack by calling
/// Dart_PropagateError, Dart_SetReturnValue, or Dart_ThrowException.
/// Errors should be propagated unless there is a specific reason not
/// to.  If an error is not propagated then it is ignored.  For
/// example, if an unhandled exception error is ignored, that
/// effectively "catches" the unhandled exception.  Fatal errors must
/// always be propagated.
///
/// When an error is propagated, any current scopes created by
/// Dart_EnterScope will be exited.
///
/// Using Dart_SetReturnValue to propagate an exception is somewhat
/// more convenient than using Dart_PropagateError, and should be
/// preferred for reasons discussed below.
///
/// Dart_PropagateError and Dart_ThrowException do not return.  Instead
/// they transfer control non-locally using a setjmp-like mechanism.
/// This can be inconvenient if you have resources that you need to
/// clean up before propagating the error.
///
/// When relying on Dart_PropagateError, we often return error handles
/// rather than propagating them from helper functions.  Consider the
/// following contrived example:
///
/// 1    Dart_Handle isLongStringHelper(Dart_Handle arg) {
/// 2      intptr_t* length = 0;
/// 3      result = Dart_StringLength(arg, &length);
/// 4      if (Dart_IsError(result)) {
/// 5        return result;
/// 6      }
/// 7      return Dart_NewBoolean(length > 100);
/// 8    }
/// 9
/// 10   void NativeFunction_isLongString(Dart_NativeArguments args) {
/// 11     Dart_EnterScope();
/// 12     AllocateMyResource();
/// 13     Dart_Handle arg = Dart_GetNativeArgument(args, 0);
/// 14     Dart_Handle result = isLongStringHelper(arg);
/// 15     if (Dart_IsError(result)) {
/// 16       FreeMyResource();
/// 17       Dart_PropagateError(result);
/// 18       abort();  // will not reach here
/// 19     }
/// 20     Dart_SetReturnValue(result);
/// 21     FreeMyResource();
/// 22     Dart_ExitScope();
/// 23   }
///
/// In this example, we have a native function which calls a helper
/// function to do its work.  On line 5, the helper function could call
/// Dart_PropagateError, but that would not give the native function a
/// chance to call FreeMyResource(), causing a leak.  Instead, the
/// helper function returns the error handle to the caller, giving the
/// caller a chance to clean up before propagating the error handle.
///
/// When an error is propagated by calling Dart_SetReturnValue, the
/// native function will be allowed to complete normally and then the
/// exception will be propagated only once the native call
/// returns. This can be convenient, as it allows the C code to clean
/// up normally.
///
/// The example can be written more simply using Dart_SetReturnValue to
/// propagate the error.
///
/// 1    Dart_Handle isLongStringHelper(Dart_Handle arg) {
/// 2      intptr_t* length = 0;
/// 3      result = Dart_StringLength(arg, &length);
/// 4      if (Dart_IsError(result)) {
/// 5        return result
/// 6      }
/// 7      return Dart_NewBoolean(length > 100);
/// 8    }
/// 9
/// 10   void NativeFunction_isLongString(Dart_NativeArguments args) {
/// 11     Dart_EnterScope();
/// 12     AllocateMyResource();
/// 13     Dart_Handle arg = Dart_GetNativeArgument(args, 0);
/// 14     Dart_SetReturnValue(isLongStringHelper(arg));
/// 15     FreeMyResource();
/// 16     Dart_ExitScope();
/// 17   }
///
/// In this example, the call to Dart_SetReturnValue on line 14 will
/// either return the normal return value or the error (potentially
/// generated on line 3).  The call to FreeMyResource on line 15 will
/// execute in either case.
///
/// --- Local and persistent handles ---
///
/// Local handles are allocated within the current scope (see
/// Dart_EnterScope) and go away when the current scope exits. Unless
/// otherwise indicated, callers should assume that all functions in
/// the Dart embedding api return local handles.
///
/// Persistent handles are allocated within the current isolate. They
/// can be used to store objects across scopes. Persistent handles have
/// the lifetime of the current isolate unless they are explicitly
/// deallocated (see Dart_DeletePersistentHandle).
/// The type Dart_Handle represents a handle (both local and persistent).
/// The type Dart_PersistentHandle is a Dart_Handle and it is used to
/// document that a persistent handle is expected as a parameter to a call
/// or the return value from a call is a persistent handle.
///
/// FinalizableHandles are persistent handles which are auto deleted when
/// the object is garbage collected. It is never safe to use these handles
/// unless you know the object is still reachable.
///
/// WeakPersistentHandles are persistent handles which are automatically set
/// to point Dart_Null when the object is garbage collected. They are not auto
/// deleted, so it is safe to use them after the object has become unreachable.
pub type Dart_Handle = *mut _Dart_Handle;
pub type Dart_PersistentHandle = Dart_Handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_WeakPersistentHandle {
	_unused: [u8; 0],
}
pub type Dart_WeakPersistentHandle = *mut _Dart_WeakPersistentHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_FinalizableHandle {
	_unused: [u8; 0],
}
pub type Dart_FinalizableHandle = *mut _Dart_FinalizableHandle;
pub type Dart_HandleFinalizer = ::std::option::Option<
	unsafe extern "C" fn(isolate_callback_data: *mut ::std::os::raw::c_void, peer: *mut ::std::os::raw::c_void),
>;
/// A port is used to send or receive inter-isolate messages
pub type Dart_Port = i64;
pub const Dart_TypedData_Type_Dart_TypedData_kByteData: Dart_TypedData_Type = Dart_TypedData_Type(0);
pub const Dart_TypedData_Type_Dart_TypedData_kInt8: Dart_TypedData_Type = Dart_TypedData_Type(1);
pub const Dart_TypedData_Type_Dart_TypedData_kUint8: Dart_TypedData_Type = Dart_TypedData_Type(2);
pub const Dart_TypedData_Type_Dart_TypedData_kUint8Clamped: Dart_TypedData_Type = Dart_TypedData_Type(3);
pub const Dart_TypedData_Type_Dart_TypedData_kInt16: Dart_TypedData_Type = Dart_TypedData_Type(4);
pub const Dart_TypedData_Type_Dart_TypedData_kUint16: Dart_TypedData_Type = Dart_TypedData_Type(5);
pub const Dart_TypedData_Type_Dart_TypedData_kInt32: Dart_TypedData_Type = Dart_TypedData_Type(6);
pub const Dart_TypedData_Type_Dart_TypedData_kUint32: Dart_TypedData_Type = Dart_TypedData_Type(7);
pub const Dart_TypedData_Type_Dart_TypedData_kInt64: Dart_TypedData_Type = Dart_TypedData_Type(8);
pub const Dart_TypedData_Type_Dart_TypedData_kUint64: Dart_TypedData_Type = Dart_TypedData_Type(9);
pub const Dart_TypedData_Type_Dart_TypedData_kFloat32: Dart_TypedData_Type = Dart_TypedData_Type(10);
pub const Dart_TypedData_Type_Dart_TypedData_kFloat64: Dart_TypedData_Type = Dart_TypedData_Type(11);
pub const Dart_TypedData_Type_Dart_TypedData_kInt32x4: Dart_TypedData_Type = Dart_TypedData_Type(12);
pub const Dart_TypedData_Type_Dart_TypedData_kFloat32x4: Dart_TypedData_Type = Dart_TypedData_Type(13);
pub const Dart_TypedData_Type_Dart_TypedData_kFloat64x2: Dart_TypedData_Type = Dart_TypedData_Type(14);
pub const Dart_TypedData_Type_Dart_TypedData_kInvalid: Dart_TypedData_Type = Dart_TypedData_Type(15);
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Dart_TypedData_Type(pub ::std::os::raw::c_int);
pub const Dart_CObject_Type_Dart_CObject_kNull: Dart_CObject_Type = Dart_CObject_Type(0);
pub const Dart_CObject_Type_Dart_CObject_kBool: Dart_CObject_Type = Dart_CObject_Type(1);
pub const Dart_CObject_Type_Dart_CObject_kInt32: Dart_CObject_Type = Dart_CObject_Type(2);
pub const Dart_CObject_Type_Dart_CObject_kInt64: Dart_CObject_Type = Dart_CObject_Type(3);
pub const Dart_CObject_Type_Dart_CObject_kDouble: Dart_CObject_Type = Dart_CObject_Type(4);
pub const Dart_CObject_Type_Dart_CObject_kString: Dart_CObject_Type = Dart_CObject_Type(5);
pub const Dart_CObject_Type_Dart_CObject_kArray: Dart_CObject_Type = Dart_CObject_Type(6);
pub const Dart_CObject_Type_Dart_CObject_kTypedData: Dart_CObject_Type = Dart_CObject_Type(7);
pub const Dart_CObject_Type_Dart_CObject_kExternalTypedData: Dart_CObject_Type = Dart_CObject_Type(8);
pub const Dart_CObject_Type_Dart_CObject_kUnmodifiableExternalTypedData: Dart_CObject_Type = Dart_CObject_Type(9);
pub const Dart_CObject_Type_Dart_CObject_kSendPort: Dart_CObject_Type = Dart_CObject_Type(10);
pub const Dart_CObject_Type_Dart_CObject_kCapability: Dart_CObject_Type = Dart_CObject_Type(11);
pub const Dart_CObject_Type_Dart_CObject_kNativePointer: Dart_CObject_Type = Dart_CObject_Type(12);
pub const Dart_CObject_Type_Dart_CObject_kUnsupported: Dart_CObject_Type = Dart_CObject_Type(13);
pub const Dart_CObject_Type_Dart_CObject_kNumberOfTypes: Dart_CObject_Type = Dart_CObject_Type(14);
#[repr(transparent)]
/// A Dart_CObject is used for representing Dart objects as native C
/// data outside the Dart heap. These objects are totally detached from
/// the Dart heap. Only a subset of the Dart objects have a
/// representation as a Dart_CObject.
///
/// The string encoding in the 'value.as_string' is UTF-8.
///
/// All the different types from dart:typed_data are exposed as type
/// kTypedData. The specific type from dart:typed_data is in the type
/// field of the as_typed_data structure. The length in the
/// as_typed_data structure is always in bytes.
///
/// The data for kTypedData is copied on message send and ownership remains with
/// the caller. The ownership of data for kExternalTyped is passed to the VM on
/// message send and returned when the VM invokes the
/// Dart_HandleFinalizer callback; a non-NULL callback must be provided.
///
/// Note that Dart_CObject_kNativePointer is intended for internal use by
/// dart:io implementation and has no connection to dart:ffi Pointer class.
/// It represents a pointer to a native resource of a known type.
/// The receiving side will only see this pointer as an integer and will not
/// see the specified finalizer.
/// The specified finalizer will only be invoked if the message is not delivered.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Dart_CObject_Type(pub ::std::os::raw::c_int);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Dart_CObject {
	pub type_: Dart_CObject_Type,
	pub value: _Dart_CObject__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _Dart_CObject__bindgen_ty_1 {
	pub as_bool: bool,
	pub as_int32: i32,
	pub as_int64: i64,
	pub as_double: f64,
	pub as_string: *mut ::std::os::raw::c_char,
	pub as_send_port: _Dart_CObject__bindgen_ty_1__bindgen_ty_1,
	pub as_capability: _Dart_CObject__bindgen_ty_1__bindgen_ty_2,
	pub as_array: _Dart_CObject__bindgen_ty_1__bindgen_ty_3,
	pub as_typed_data: _Dart_CObject__bindgen_ty_1__bindgen_ty_4,
	pub as_external_typed_data: _Dart_CObject__bindgen_ty_1__bindgen_ty_5,
	pub as_native_pointer: _Dart_CObject__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_1 {
	pub id: Dart_Port,
	pub origin_id: Dart_Port,
}
#[test]
fn bindgen_test_layout__Dart_CObject__bindgen_ty_1__bindgen_ty_1() {
	const UNINIT: ::std::mem::MaybeUninit<_Dart_CObject__bindgen_ty_1__bindgen_ty_1> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_1>(),
		16usize,
		concat!("Size of: ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_1))
	);
	assert_eq!(
		::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_1>(),
		8usize,
		concat!("Alignment of ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_1))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).origin_id) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(origin_id)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_2 {
	pub id: i64,
}
#[test]
fn bindgen_test_layout__Dart_CObject__bindgen_ty_1__bindgen_ty_2() {
	const UNINIT: ::std::mem::MaybeUninit<_Dart_CObject__bindgen_ty_1__bindgen_ty_2> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_2>(),
		8usize,
		concat!("Size of: ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_2))
	);
	assert_eq!(
		::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_2>(),
		8usize,
		concat!("Alignment of ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_2))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_2),
			"::",
			stringify!(id)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_3 {
	pub length: isize,
	pub values: *mut *mut _Dart_CObject,
}
#[test]
fn bindgen_test_layout__Dart_CObject__bindgen_ty_1__bindgen_ty_3() {
	const UNINIT: ::std::mem::MaybeUninit<_Dart_CObject__bindgen_ty_1__bindgen_ty_3> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_3>(),
		16usize,
		concat!("Size of: ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_3))
	);
	assert_eq!(
		::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_3>(),
		8usize,
		concat!("Alignment of ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_3))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_3),
			"::",
			stringify!(length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_3),
			"::",
			stringify!(values)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_4 {
	pub type_: Dart_TypedData_Type,
	pub length: isize,
	pub values: *const u8,
}
#[test]
fn bindgen_test_layout__Dart_CObject__bindgen_ty_1__bindgen_ty_4() {
	const UNINIT: ::std::mem::MaybeUninit<_Dart_CObject__bindgen_ty_1__bindgen_ty_4> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_4>(),
		24usize,
		concat!("Size of: ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_4))
	);
	assert_eq!(
		::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_4>(),
		8usize,
		concat!("Alignment of ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_4))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_4),
			"::",
			stringify!(type_)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_4),
			"::",
			stringify!(length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_4),
			"::",
			stringify!(values)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_5 {
	pub type_: Dart_TypedData_Type,
	pub length: isize,
	pub data: *mut u8,
	pub peer: *mut ::std::os::raw::c_void,
	pub callback: Dart_HandleFinalizer,
}
#[test]
fn bindgen_test_layout__Dart_CObject__bindgen_ty_1__bindgen_ty_5() {
	const UNINIT: ::std::mem::MaybeUninit<_Dart_CObject__bindgen_ty_1__bindgen_ty_5> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_5>(),
		40usize,
		concat!("Size of: ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5))
	);
	assert_eq!(
		::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_5>(),
		8usize,
		concat!("Alignment of ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5),
			"::",
			stringify!(type_)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5),
			"::",
			stringify!(length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5),
			"::",
			stringify!(data)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).peer) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5),
			"::",
			stringify!(peer)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_5),
			"::",
			stringify!(callback)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_CObject__bindgen_ty_1__bindgen_ty_6 {
	pub ptr: isize,
	pub size: isize,
	pub callback: Dart_HandleFinalizer,
}
#[test]
fn bindgen_test_layout__Dart_CObject__bindgen_ty_1__bindgen_ty_6() {
	const UNINIT: ::std::mem::MaybeUninit<_Dart_CObject__bindgen_ty_1__bindgen_ty_6> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_6>(),
		24usize,
		concat!("Size of: ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_6))
	);
	assert_eq!(
		::std::mem::align_of::<_Dart_CObject__bindgen_ty_1__bindgen_ty_6>(),
		8usize,
		concat!("Alignment of ", stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_6))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_6),
			"::",
			stringify!(ptr)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_6),
			"::",
			stringify!(size)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1__bindgen_ty_6),
			"::",
			stringify!(callback)
		)
	);
}
#[test]
fn bindgen_test_layout__Dart_CObject__bindgen_ty_1() {
	const UNINIT: ::std::mem::MaybeUninit<_Dart_CObject__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_Dart_CObject__bindgen_ty_1>(),
		40usize,
		concat!("Size of: ", stringify!(_Dart_CObject__bindgen_ty_1))
	);
	assert_eq!(
		::std::mem::align_of::<_Dart_CObject__bindgen_ty_1>(),
		8usize,
		concat!("Alignment of ", stringify!(_Dart_CObject__bindgen_ty_1))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_bool) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_bool)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_int32) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_int32)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_int64) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_int64)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_double) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_double)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_string) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_string)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_send_port) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_send_port)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_capability) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_capability)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_array) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_array)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_typed_data) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_typed_data)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_external_typed_data) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_external_typed_data)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).as_native_pointer) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_Dart_CObject__bindgen_ty_1),
			"::",
			stringify!(as_native_pointer)
		)
	);
}
#[test]
fn bindgen_test_layout__Dart_CObject() {
	const UNINIT: ::std::mem::MaybeUninit<_Dart_CObject> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_Dart_CObject>(),
		48usize,
		concat!("Size of: ", stringify!(_Dart_CObject))
	);
	assert_eq!(
		::std::mem::align_of::<_Dart_CObject>(),
		8usize,
		concat!("Alignment of ", stringify!(_Dart_CObject))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
		0usize,
		concat!("Offset of field: ", stringify!(_Dart_CObject), "::", stringify!(type_))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
		8usize,
		concat!("Offset of field: ", stringify!(_Dart_CObject), "::", stringify!(value))
	);
}
pub type Dart_CObject = _Dart_CObject;
extern "C" {
	/// \mainpage Dynamically Linked Dart API
	///
	/// This exposes a subset of symbols from dart_api.h and dart_native_api.h
	/// available in every Dart embedder through dynamic linking.
	///
	/// All symbols are postfixed with _DL to indicate that they are dynamically
	/// linked and to prevent conflicts with the original symbol.
	///
	/// Link `dart_api_dl.c` file into your library and invoke
	/// `Dart_InitializeApiDL` with `NativeApi.initializeApiDLData`.
	pub fn Dart_InitializeApiDL(data: *mut ::std::os::raw::c_void) -> isize;
}
pub type Dart_Port_DL = i64;
pub type Dart_NativeMessageHandler_DL =
	::std::option::Option<unsafe extern "C" fn(dest_port_id: Dart_Port_DL, message: *mut Dart_CObject)>;
pub type Dart_PostCObject_Type =
	::std::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL, message: *mut Dart_CObject) -> bool>;
extern "C" {
	pub static mut Dart_PostCObject_DL: Dart_PostCObject_Type;
}
pub type Dart_PostInteger_Type =
	::std::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL, message: i64) -> bool>;
extern "C" {
	pub static mut Dart_PostInteger_DL: Dart_PostInteger_Type;
}
pub type Dart_NewNativePort_Type = ::std::option::Option<
	unsafe extern "C" fn(
		name: *const ::std::os::raw::c_char,
		handler: Dart_NativeMessageHandler_DL,
		handle_concurrently: bool,
	) -> Dart_Port_DL,
>;
extern "C" {
	pub static mut Dart_NewNativePort_DL: Dart_NewNativePort_Type;
}
pub type Dart_CloseNativePort_Type = ::std::option::Option<unsafe extern "C" fn(native_port_id: Dart_Port_DL) -> bool>;
extern "C" {
	pub static mut Dart_CloseNativePort_DL: Dart_CloseNativePort_Type;
}
pub type Dart_IsError_Type = ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
extern "C" {
	pub static mut Dart_IsError_DL: Dart_IsError_Type;
}
pub type Dart_IsApiError_Type = ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
extern "C" {
	pub static mut Dart_IsApiError_DL: Dart_IsApiError_Type;
}
pub type Dart_IsUnhandledExceptionError_Type = ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
extern "C" {
	pub static mut Dart_IsUnhandledExceptionError_DL: Dart_IsUnhandledExceptionError_Type;
}
pub type Dart_IsCompilationError_Type = ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
extern "C" {
	pub static mut Dart_IsCompilationError_DL: Dart_IsCompilationError_Type;
}
pub type Dart_IsFatalError_Type = ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
extern "C" {
	pub static mut Dart_IsFatalError_DL: Dart_IsFatalError_Type;
}
pub type Dart_GetError_Type =
	::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> *const ::std::os::raw::c_char>;
extern "C" {
	pub static mut Dart_GetError_DL: Dart_GetError_Type;
}
pub type Dart_ErrorHasException_Type = ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> bool>;
extern "C" {
	pub static mut Dart_ErrorHasException_DL: Dart_ErrorHasException_Type;
}
pub type Dart_ErrorGetException_Type = ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> Dart_Handle>;
extern "C" {
	pub static mut Dart_ErrorGetException_DL: Dart_ErrorGetException_Type;
}
pub type Dart_ErrorGetStackTrace_Type = ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle) -> Dart_Handle>;
extern "C" {
	pub static mut Dart_ErrorGetStackTrace_DL: Dart_ErrorGetStackTrace_Type;
}
pub type Dart_NewApiError_Type =
	::std::option::Option<unsafe extern "C" fn(error: *const ::std::os::raw::c_char) -> Dart_Handle>;
extern "C" {
	pub static mut Dart_NewApiError_DL: Dart_NewApiError_Type;
}
pub type Dart_NewCompilationError_Type =
	::std::option::Option<unsafe extern "C" fn(error: *const ::std::os::raw::c_char) -> Dart_Handle>;
extern "C" {
	pub static mut Dart_NewCompilationError_DL: Dart_NewCompilationError_Type;
}
pub type Dart_NewUnhandledExceptionError_Type =
	::std::option::Option<unsafe extern "C" fn(exception: Dart_Handle) -> Dart_Handle>;
extern "C" {
	pub static mut Dart_NewUnhandledExceptionError_DL: Dart_NewUnhandledExceptionError_Type;
}
pub type Dart_PropagateError_Type = ::std::option::Option<unsafe extern "C" fn(handle: Dart_Handle)>;
extern "C" {
	pub static mut Dart_PropagateError_DL: Dart_PropagateError_Type;
}
pub type Dart_HandleFromPersistent_Type =
	::std::option::Option<unsafe extern "C" fn(object: Dart_PersistentHandle) -> Dart_Handle>;
extern "C" {
	pub static mut Dart_HandleFromPersistent_DL: Dart_HandleFromPersistent_Type;
}
pub type Dart_HandleFromWeakPersistent_Type =
	::std::option::Option<unsafe extern "C" fn(object: Dart_WeakPersistentHandle) -> Dart_Handle>;
extern "C" {
	pub static mut Dart_HandleFromWeakPersistent_DL: Dart_HandleFromWeakPersistent_Type;
}
pub type Dart_NewPersistentHandle_Type =
	::std::option::Option<unsafe extern "C" fn(object: Dart_Handle) -> Dart_PersistentHandle>;
extern "C" {
	pub static mut Dart_NewPersistentHandle_DL: Dart_NewPersistentHandle_Type;
}
pub type Dart_SetPersistentHandle_Type =
	::std::option::Option<unsafe extern "C" fn(obj1: Dart_PersistentHandle, obj2: Dart_Handle)>;
extern "C" {
	pub static mut Dart_SetPersistentHandle_DL: Dart_SetPersistentHandle_Type;
}
pub type Dart_DeletePersistentHandle_Type = ::std::option::Option<unsafe extern "C" fn(object: Dart_PersistentHandle)>;
extern "C" {
	pub static mut Dart_DeletePersistentHandle_DL: Dart_DeletePersistentHandle_Type;
}
pub type Dart_NewWeakPersistentHandle_Type = ::std::option::Option<
	unsafe extern "C" fn(
		object: Dart_Handle,
		peer: *mut ::std::os::raw::c_void,
		external_allocation_size: isize,
		callback: Dart_HandleFinalizer,
	) -> Dart_WeakPersistentHandle,
>;
extern "C" {
	pub static mut Dart_NewWeakPersistentHandle_DL: Dart_NewWeakPersistentHandle_Type;
}
pub type Dart_DeleteWeakPersistentHandle_Type =
	::std::option::Option<unsafe extern "C" fn(object: Dart_WeakPersistentHandle)>;
extern "C" {
	pub static mut Dart_DeleteWeakPersistentHandle_DL: Dart_DeleteWeakPersistentHandle_Type;
}
pub type Dart_UpdateExternalSize_Type =
	::std::option::Option<unsafe extern "C" fn(object: Dart_WeakPersistentHandle, external_allocation_size: isize)>;
extern "C" {
	pub static mut Dart_UpdateExternalSize_DL: Dart_UpdateExternalSize_Type;
}
pub type Dart_NewFinalizableHandle_Type = ::std::option::Option<
	unsafe extern "C" fn(
		object: Dart_Handle,
		peer: *mut ::std::os::raw::c_void,
		external_allocation_size: isize,
		callback: Dart_HandleFinalizer,
	) -> Dart_FinalizableHandle,
>;
extern "C" {
	pub static mut Dart_NewFinalizableHandle_DL: Dart_NewFinalizableHandle_Type;
}
pub type Dart_DeleteFinalizableHandle_Type =
	::std::option::Option<unsafe extern "C" fn(object: Dart_FinalizableHandle, strong_ref_to_object: Dart_Handle)>;
extern "C" {
	pub static mut Dart_DeleteFinalizableHandle_DL: Dart_DeleteFinalizableHandle_Type;
}
pub type Dart_UpdateFinalizableExternalSize_Type = ::std::option::Option<
	unsafe extern "C" fn(
		object: Dart_FinalizableHandle,
		strong_ref_to_object: Dart_Handle,
		external_allocation_size: isize,
	),
>;
extern "C" {
	pub static mut Dart_UpdateFinalizableExternalSize_DL: Dart_UpdateFinalizableExternalSize_Type;
}
pub type Dart_Post_Type =
	::std::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL, object: Dart_Handle) -> bool>;
extern "C" {
	pub static mut Dart_Post_DL: Dart_Post_Type;
}
pub type Dart_NewSendPort_Type = ::std::option::Option<unsafe extern "C" fn(port_id: Dart_Port_DL) -> Dart_Handle>;
extern "C" {
	pub static mut Dart_NewSendPort_DL: Dart_NewSendPort_Type;
}
pub type Dart_SendPortGetId_Type =
	::std::option::Option<unsafe extern "C" fn(port: Dart_Handle, port_id: *mut Dart_Port_DL) -> Dart_Handle>;
extern "C" {
	pub static mut Dart_SendPortGetId_DL: Dart_SendPortGetId_Type;
}
pub type Dart_EnterScope_Type = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
	pub static mut Dart_EnterScope_DL: Dart_EnterScope_Type;
}
pub type Dart_ExitScope_Type = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
	pub static mut Dart_ExitScope_DL: Dart_ExitScope_Type;
}
pub type Dart_IsNull_Type = ::std::option::Option<unsafe extern "C" fn(arg1: Dart_Handle) -> bool>;
extern "C" {
	pub static mut Dart_IsNull_DL: Dart_IsNull_Type;
}
